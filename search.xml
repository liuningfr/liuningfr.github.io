<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Vue底层实现原理概述</title>
      <link href="/2018/10/08/Vue%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/"/>
      <url>/2018/10/08/Vue%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在研究 <a href="https://segmentfault.com/a/1190000006599500" target="_blank" rel="noopener">剖析Vue原理&amp;实现双向绑定MVVM</a> 这篇文章，一边学习一边总结一下自己的思考。</p><p>Vue是一个典型的MVVM框架，模型（Model）只是普通的JavaScript对象，修改它则视图（View）会自动更新。这种设计让状态管理变得非常简单而直观。那么Vue是如何把模型和视图建立起关联的呢？</p><h2 id="实现原理概述"><a href="#实现原理概述" class="headerlink" title="实现原理概述"></a>实现原理概述</h2><p>这是前言提到的文章里的代码，一段典型的体现了Vue特点的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"mvvm-app"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> v-model=<span class="string">"word"</span>&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;word&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button v-on:click="sayHi"&gt;change model&lt;/</span>button&gt; <span class="comment">//点击这个button，word的值会发生改变</span></span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script src="./</span>js/observer.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;script src="</span>./js/watcher.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;script src="</span>./js/compile.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;script src="</span>./js/mvvm.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">    var vm = new MVVM(&#123;</span></span><br><span class="line"><span class="string">        el: '#mvvm-app',</span></span><br><span class="line"><span class="string">        data: &#123;</span></span><br><span class="line"><span class="string">            word: 'Hello World!'</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        methods: &#123;</span></span><br><span class="line"><span class="string">            sayHi: function() &#123;</span></span><br><span class="line"><span class="string">                this.word = 'Hi, everybody!';</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>Vue实现这种数据双向绑定的效果，需要三大模块：</p><ol><li><p><strong>Observer</strong>：能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者</p></li><li><p><strong>Compile</strong>：对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数</p></li><li><p><strong>Watcher</strong>：作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图</p></li></ol><h2 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h2><p>Observer的核心是通过<code>Obeject.defineProperty()</code>来监听数据的变动，这个函数内部可以定义<code>setter</code>和<code>getter</code>，每当数据发生变化，就会触发<code>setter</code>。这时候<code>Observer</code>就要通知订阅者，订阅者就是<code>Watcher</code>。</p><h2 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h2><p><code>Watcher</code>订阅者作为<code>Observer</code>和<code>Compile</code>之间通信的桥梁，主要做的事情是：</p><ol><li>在自身实例化时往属性订阅器(dep)里面添加自己</li><li>自身必须有一个<code>update()</code>方法</li><li>待属性变动<code>dep.notice()</code>通知时，能调用自身的update()方法，并触发<code>Compile</code>中绑定的回调</li></ol><h2 id="Compile"><a href="#Compile" class="headerlink" title="Compile"></a>Compile</h2><p><code>Compile</code>主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于每部分具体的代码实现，可以参阅 <a href="https://segmentfault.com/a/1190000006599500" target="_blank" rel="noopener">剖析Vue原理&amp;实现双向绑定MVVM</a> 这篇文章，这篇文章写得非常好。我打算研究透彻之后自己实现一下简易的Vue框架。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>如果你还搞不懂HTTP报文</title>
      <link href="/2018/10/08/%E5%A6%82%E6%9E%9C%E4%BD%A0%E8%BF%98%E6%90%9E%E4%B8%8D%E6%87%82HTTP%E6%8A%A5%E6%96%87/"/>
      <url>/2018/10/08/%E5%A6%82%E6%9E%9C%E4%BD%A0%E8%BF%98%E6%90%9E%E4%B8%8D%E6%87%82HTTP%E6%8A%A5%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>HTTP报文由三部分组成：</p><ol><li><strong>起始行</strong>：报文的第一行就是起始行,在请求报文中用来说明要做些什么,在响应报文中说明出现了什么情况</li><li><strong>报文头</strong>：起始行后面有零个或多个字段。每个字段都包含一个名字和一个值,为了便于解析,两者之间用冒号(:)来分隔，<strong>首部以一个空行结束</strong>。</li><li><strong>主体</strong>：空行之后就是可选的报文主体了，其中包含了所有类型的数据。请求主体是要发送给服务器的数据;响应主体是要返回给客户端的数据。起始行和报文都是文本且都是结构化的,而主体则不同,主体中可以包含任意的二进制数据(比如图片、视频)。当然,主体中也可以包含文本。</li></ol><h2 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h2><p>一个请求报文<strong>起始行</strong>的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /dir/index.html HTTP/1.1</span><br></pre></td></tr></table></figure><ul><li>GET：这里指明请求方法是GET，还有其它方法比如POST、DELETE、HEAD、OPTIONS、PUT、TRACE</li><li>/dir/index.html：这里指明URL，它和报文头的Host属性组成完整的请求URL</li><li>HTTP/1.1：这里指明协议名称及版本号</li></ul><p><strong>报文头</strong>里有很多的字段，具几个常见的例子：</p><ul><li><code>Host</code>：请求的服务器地址，比如<a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a></li><li><code>Accept</code>: 指明客户端可以接受的数据类型，比如text/html</li><li><code>Cookie</code>：携带的Cookie信息</li><li><code>Cache-Control</code>：对缓存进行控制，指明一个请求希望响应返回的内容在客户端要被缓存多久或是否缓存</li></ul><p>还有非常多的字段，可以查阅文档，例如 [HTTP MDN][1]</p><p>最后举一个<strong>请求主体</strong>的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=ning&amp;age=24</span><br></pre></td></tr></table></figure><p>这里的请求主体就是我们提交的表单里的数据。</p><h2 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h2><p>一个响应报文<strong>起始行</strong>的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure><p>跟请求报文比，响应报文的起始行里多了一个状态码来告诉客户端本次请求的处理结果。以下是状态码的类型：</p><p><img src="https://ws1.sinaimg.cn/large/0072eorIgy1fw0t0vqqghj30ko072glr.jpg" alt="状态码类型"></p><p>例如：<br>200 OK<br>303 See Other<br>304 Not Modified<br>404 Not Found<br>500 Internal Server Error </p><p>关于响应报文头里面的各种字段，可以查阅文档 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP" target="_blank" rel="noopener">HTTP MDN</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这些就是关于HTTP报文的基本知识点，其实内容最多地方是报文头里各种字段的用法，比如很多字段是用来做浏览器缓存控制的。因为涉及字段的内容太多了，更具体的字段用法可以查阅文档 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP" target="_blank" rel="noopener">HTTP MDN</a>。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>跨域问题的根本解决方案CORS</title>
      <link href="/2018/10/08/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B9%E6%9C%AC%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88CORS/"/>
      <url>/2018/10/08/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B9%E6%9C%AC%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88CORS/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>关于跨域问题有很多的解决方案，这里我们总结一下目前最通用最强大的解决方案：CORS。</p><p>W3C 的 Web 工作组推荐了一种新的机制，即跨域资源共享（Cross-origin Resource Sharing），简称CORS。其实这个机制就是实现了跨站访问控制，使得安全地进行跨站数据传输成为可能。</p><p>跨源资源共享标准( cross-origin sharing standard) 使得以下场景可以使用跨站 HTTP 请求：</p><ol><li>使用 XMLHttpRequest 或 Fetch发起跨站 HTTP 请求。</li><li>Web 字体 (CSS 中通过 @font-face 使用跨站字体资源)，因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用。</li><li>WebGL 贴图</li><li>使用drawImage绘制</li><li>Images/video 画面到canvas.</li><li>样式表（使用 CSSOM）</li><li>Scripts (for unmuted exceptions)</li></ol><p>CORS分为<strong>简单请求</strong>和<strong>复杂请求</strong>，处理方法也是有不同的，所以我们分别总结。</p><h1 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h1><p>什么是简单请求呢？同时满足以下两个条件，就是简单请求：</p><ol><li>请求是下列之一：<br><code>HEAD</code><br><code>GET</code><br><code>POST</code></li><li>HTTP的头信息不超出以下几种字段：<br><code>Accept</code><br><code>Accept-Language</code><br><code>Content-Language</code><br><code>Last-Event-ID</code><br><code>Content-Type</code>：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</li></ol><p>实现方法非常简单，只需要把服务器的响应报文里的<code>Access-Control-Allow-Origin</code>设置为<code>*</code>或者包含由 <code>Origin</code>指明的站点。</p><p><code>Access-Control-Allow-Origin</code>是<strong>HTTP响应报文</strong>中的一个字段，<code>Origin</code>是<strong>HTTP请求报文</strong>中的以一个字段,如果不清楚这两个字段的话，可以自行查阅关于<strong>HTTP报文</strong>的知识，比如<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP" target="_blank" rel="noopener">HTTP | MDN</a>。</p><h1 id="复杂请求"><a href="#复杂请求" class="headerlink" title="复杂请求"></a>复杂请求</h1><p>如果不是简单请求，那就是复杂请求，比如请求的方法是<code>PUT</code>或者<code>DELETE</code>，比如<code>Content-Type</code>字段的类型是application/json，比如设置了自定义头信息。</p><p>复杂请求就是比简单请求多了个预检请求（preflight）而已。</p><p>预检请求就是浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。</p><p>预检请求用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字段是<code>Origin</code>，表示请求来自哪个源。除了<code>Origin</code>字段，还有两个字段非常重要：<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>，分别表示允许的请求方法和请求头。</p><p>举一个具体的例子：</p><p>现在，我们有一个页面向服务器发送了一个<code>POST</code>请求，并且我们自己定义了一个请求头字段<code>My-HEADER</code>，这时候浏览器就会首先发送一个<code>OPTION</code>请求来做预检请求，请求头里有以下字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Request-Method: POST</span><br><span class="line">Access-Control-Request-Headers: My-HEADER</span><br></pre></td></tr></table></figure><p>如果预检请求成功的话，响应头里的内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://example.com //表明服务器允许http://example.com的请求</span><br><span class="line">Access-Control-Allow-Methods: POST, GET, OPTIONS //表明服务器可以接受POST, GET和 OPTIONS的请求方法</span><br><span class="line">Access-Control-Allow-Headers: My-HEADER //传递一个可接受的自定义请求头列表</span><br><span class="line">Access-Control-Max-Age: 3000000 //告诉浏览器，本次预检请求的响应结果有效时间是多久</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是CORS方法解决跨域问题的流程，CORS支持所有类型的HTTP请求，是目前跨域问题的根本解决方案。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>什么是跨域以及几种简单解决方案</title>
      <link href="/2018/10/08/%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%E4%BB%A5%E5%8F%8A%E5%87%A0%E7%A7%8D%E7%AE%80%E5%8D%95%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2018/10/08/%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%E4%BB%A5%E5%8F%8A%E5%87%A0%E7%A7%8D%E7%AE%80%E5%8D%95%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a>什么是跨域？</h1><p>要明白什么是跨域之前，首先要明白什么是<strong>同源策略</strong>？</p><p>同源策略就是用来限制从一个源加载的文档或脚本与来自另一个源的资源进行交互。那怎样判断是否是同源呢？</p><p>如果协议，端口（如果指定了）和主机对于两个页面是相同的，则两个页面具有相同的源，也就是同源。也就是说，要同时满足以下3个条件，才能叫同源：</p><ol><li>协议相同</li><li>端口相同</li><li>主机相同</li></ol><p>举个例子就一目了然了：</p><p>我们来看下面的页面是否与 <code>http://store.company.com/dir/index.html</code> 是同源的？</p><ol><li><code>http://store.company.com/dir/index2.html</code>   同源 </li><li><code>http://store.company.com/dir2/index3.html</code>  同源 虽然在不同文件夹下</li><li><code>https://store.company.com/secure.html</code>     不同源 不同的协议(https) </li><li><code>http://store.company.com:81/dir/index.html</code> 不同源 不同的端口(81) </li><li><code>http://news.company.com/dir/other.html</code>     不同源 不同的主机(news)</li></ol><p>所以当面对跨域问题的时候，有什么解决方案呢？</p><h1 id="跨域的几种解决方案"><a href="#跨域的几种解决方案" class="headerlink" title="跨域的几种解决方案"></a>跨域的几种解决方案</h1><h2 id="document-domain方法"><a href="#document-domain方法" class="headerlink" title="document.domain方法"></a>document.domain方法</h2><p>我们来看一个具体场景：有一个页面 <code>http://www.example.com/a.html</code> ，它里面有一个<code>iframe</code>，这个<code>iframe</code>的源是 <code>http://example.com/b.html</code> ，很显然它们是不同源的，所以我们无法在父页面中操控子页面的内容。</p><p>解决方案如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- b.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.domain = <span class="string">'example.com'</span>;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- a.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.domain = <span class="string">'example.com'</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>).contentWindow.document;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="comment">//后面就可以操作iframe里的内容了...</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以我们只要将两个页面的document.domain设置成一致就可以了，要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域。</p><p>但是，这种方法只能解决主域相同的跨域问题。</p><h2 id="window-name方法"><a href="#window-name方法" class="headerlink" title="window.name方法"></a>window.name方法</h2><p>window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。</p><p>我们来看一个具体场景，在一个页面 <code>example.com/a.html</code> 中，我们想获取 <code>data.com/data.html</code> 中的数据，以下是解决方案：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- data.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.name = <span class="string">'data'</span>; <span class="comment">//这是就是我们需要通信的数据</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- a.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">getData</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</span></span><br><span class="line"><span class="javascript">        iframe.src = <span class="string">'example.com/b.html'</span>; <span class="comment">// 这里让iframe与父页面同源</span></span></span><br><span class="line"><span class="undefined">        </span></span><br><span class="line"><span class="javascript">        iframe.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> data = iframe.contentWindow.name; <span class="comment">//在这里我们得到了跨域页面中传来的数据</span></span></span><br><span class="line"><span class="undefined">        &#125;;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="JSONP方法"><a href="#JSONP方法" class="headerlink" title="JSONP方法"></a>JSONP方法</h2><p>JONSP(JSON with Padding)是JSON的一种使用模式。基本原理如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- a.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">dealData</span> (<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(data);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'http://example.com/data.php?callback=dealData'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $callback = $_GET[<span class="string">'callback'</span>];</span><br><span class="line">    $data = <span class="string">'data'</span>;</span><br><span class="line">    <span class="keyword">echo</span> $callback.<span class="string">'('</span>.json_encode($data).<span class="string">')'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>这时候在<code>a.html</code>中我们得到了一条js的执行语句<code>dealData(&#39;data&#39;)</code>，从而达到了跨域的目的。</p><p>所以JSONP的原理其实就是利用引入<code>script</code>不限制源的特点，把处理函数名作为参数传入，然后返回执行语句，仔细阅读以上代码就可以明白里面的意思了。</p><p>如果在jQuery中用JSONP的话就更加简单了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">$.getJSON(<span class="string">''</span>http:<span class="comment">//example.com/data.php?callback=?', function (data) &#123;</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(data);</span></span><br><span class="line"><span class="undefined">&#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意jQuery会自动生成一个全局函数来替换<code>callback=?</code>中的问号，之后获取到数据后又会自动销毁，实际上就是起一个临时代理函数的作用。<code>$.getJSON</code>方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用JSONP的回调函数。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>除了上述方法外，HTML5还新增了一个<code>window.postMessage()</code>方法，有兴趣的可以自行查阅。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>JavaScript实现类与继承的方法（全面整理）</title>
      <link href="/2018/10/08/JavaScript%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E5%85%A8%E9%9D%A2%E6%95%B4%E7%90%86%EF%BC%89/"/>
      <url>/2018/10/08/JavaScript%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E5%85%A8%E9%9D%A2%E6%95%B4%E7%90%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript定义类的4种方法"><a href="#JavaScript定义类的4种方法" class="headerlink" title="JavaScript定义类的4种方法"></a>JavaScript定义类的4种方法</h1><h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">creatPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line">obj.name = name;</span><br><span class="line">obj.age = age;</span><br><span class="line"></span><br><span class="line">obj.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">window</span>.alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">            </span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数方法"><a href="#构造函数方法" class="headerlink" title="构造函数方法"></a>构造函数方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">window</span>.alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原型方法"><a href="#原型方法" class="headerlink" title="原型方法"></a>原型方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line"><span class="keyword">constructor</span> : Person,</span><br><span class="line">name : "Ning",</span><br><span class="line">age : "23",</span><br><span class="line">sayName : function() &#123;</span><br><span class="line"><span class="built_in">window</span>.alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>大家可以看到这种方法有缺陷，类里属性的值都是在原型里给定的。</p><h2 id="组合使用构造函数和原型方法（使用最广）"><a href="#组合使用构造函数和原型方法（使用最广）" class="headerlink" title="组合使用构造函数和原型方法（使用最广）"></a>组合使用构造函数和原型方法（使用最广）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line"><span class="keyword">constructor</span> : Person, </span><br><span class="line">sayName : function() &#123;</span><br><span class="line"><span class="built_in">window</span>.alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将构造函数方法和原型方法结合使用是目前最常用的定义类的方法。这种方法的好处是实现了属性定义和方法定义的分离。比如我可以创建两个对象<code>person1</code>和<code>person2</code>，它们分别传入各自的<code>name</code>值和<code>age</code>值，但<code>sayName()</code>方法可以同时使用原型里定义的。</p><h1 id="JavaScript实现继承的3种方法"><a href="#JavaScript实现继承的3种方法" class="headerlink" title="JavaScript实现继承的3种方法"></a>JavaScript实现继承的3种方法</h1><h2 id="借用构造函数法（又叫经典继承）"><a href="#借用构造函数法（又叫经典继承）" class="headerlink" title="借用构造函数法（又叫经典继承）"></a>借用构造函数法（又叫经典继承）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">window</span>.alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">SuperType.call(<span class="keyword">this</span>, name); <span class="comment">//在这里借用了父类的构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象冒充"><a href="#对象冒充" class="headerlink" title="对象冒充"></a>对象冒充</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">window</span>.alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.supertype = SuperType; <span class="comment">//在这里使用了对象冒充</span></span><br><span class="line"><span class="keyword">this</span>.supertype(name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合继承（最常用）"><a href="#组合继承（最常用）" class="headerlink" title="组合继承（最常用）"></a>组合继承（最常用）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype = &#123;</span><br><span class="line"></span><br><span class="line">    sayName : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">window</span>.alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">SuperType.call(<span class="keyword">this</span>, name); <span class="comment">//在这里继承属性</span></span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); <span class="comment">//这里继承方法</span></span><br></pre></td></tr></table></figure><p>组合继承的方法是对应着我们用‘组合使用构造函数和原型方法’定义父类的一种继承方法。同样的，我们的属性和方法是分开继承的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是常见的JavaScript中面向对象编程的几种实现，欢迎大家补充与指正。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>为什么要使用闭包和如何使用闭包</title>
      <link href="/2018/10/07/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85%E5%92%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85/"/>
      <url>/2018/10/07/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85%E5%92%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>JS中的闭包是一个我们经常遇到的名词，到底什么是闭包？为什么我们要使用闭包？又该如何使用闭包呢？</p><h2 id="为什么我们需要闭包"><a href="#为什么我们需要闭包" class="headerlink" title="为什么我们需要闭包"></a>为什么我们需要闭包</h2><p>首先来看一个例子，我们来实现一个计数器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> counter += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line">add();<span class="comment">// 计数器现在为 3</span></span><br></pre></td></tr></table></figure><p>现在我们已经达到了目的，可是问题来了，代码中的任何一个函数都可以随意改变<code>counter</code>的值，所以这个计数器并不完美。那我们把<code>counter</code>放在<code>add</code>函数里面不就好了么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> counter += <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line">add();<span class="comment">// 本意是想输出 3, 但输出的都是 1</span></span><br></pre></td></tr></table></figure><p>所以这样做的话，每次调用<code>add</code>函数，<code>counter</code>的值都要被初始化为0，还是达不到我们的目的。</p><h2 id="如何使用闭包"><a href="#如何使用闭包" class="headerlink" title="如何使用闭包"></a>如何使用闭包</h2><p>所以这时候我们就要用闭包去解决这个问题了，先看代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">return</span> counter += <span class="number">1</span>;&#125;</span><br><span class="line">&#125;)();</span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line">add();<span class="comment">// 计数器为 3</span></span><br></pre></td></tr></table></figure><p>这时候我们完美实现了计数器。这段非常精简，可以拆分成如下等价代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> counter += <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> innerFunction;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> add = outerFunction();</span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line">add();<span class="comment">// 计数器为 3</span></span><br></pre></td></tr></table></figure><p>这时候的<code>add</code>就形成了一个闭包。一个闭包由两部分组成，函数和创建该函数的环境。环境是由环境中的局部变量组成的。对于闭包<code>add</code>来说，它由函数<code>innerFunction</code>和变量<code>counter</code>组成，所以这时候<code>add</code>是可以访问变量<code>counter</code>的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以闭包的功能就是使一个函数能访问另一个函数作用域中的变量。形成闭包之后，该变量不会被垃圾回收机制回收。</p><p>闭包的原理其实还是作用域。</p><p>使用闭包的优点是可以避免全局变量污染，缺点是容易造成内存泄露。 </p>]]></content>
      
      
      
    </entry>
    
  
  
</search>
