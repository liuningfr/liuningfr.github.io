<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>【随笔】马孔多在下雨</title>
      <link href="/2018/10/08/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%91%E9%A9%AC%E5%AD%94%E5%A4%9A%E5%9C%A8%E4%B8%8B%E9%9B%A8/"/>
      <url>/2018/10/08/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%91%E9%A9%AC%E5%AD%94%E5%A4%9A%E5%9C%A8%E4%B8%8B%E9%9B%A8/</url>
      
        <content type="html"><![CDATA[<p>近日又翻起了《百年孤独》这本书，上一次读还是18年的3月份，我坐在从巴黎到第戎的火车上，窗外刚好是春天。</p><p>马尔克斯用他独创的魔幻现实主义手法把火车上的我带入了一个深沉的世界。</p><p>最喜欢的还是奥雷里亚诺上校和儿时好友的对话：</p><blockquote><p>“奥雷里亚诺， ”他悲伤地敲下发报键，“马孔多在下雨。”</p></blockquote><blockquote><p>线路上一阵长久的沉默。忽然，机器上跳出奥雷里亚诺上校冷漠的电码。</p></blockquote><blockquote><p>“别犯傻了，赫里内勒多，”电码如是说道，“八月下雨很正常。”</p></blockquote><p>“马孔多在下雨。” 这是赫里内勒多最后的矫情。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>快速了解React的组件生命周期</title>
      <link href="/2018/10/08/%E5%BF%AB%E9%80%9F%E4%BA%86%E8%A7%A3React%E7%9A%84%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2018/10/08/%E5%BF%AB%E9%80%9F%E4%BA%86%E8%A7%A3React%E7%9A%84%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>工作快要满两个月了，一直在使用React全家桶（React + React Redux + Router + Ant Design）。工作中涉及到React生命周期函数的使用非常多，在此做一个整理。</p><h2 id="React的组件生命周期"><a href="#React的组件生命周期" class="headerlink" title="React的组件生命周期"></a>React的组件生命周期</h2><p>在这里我想引用 <a href="http://www.css88.com/react/docs/react-component.html" target="_blank" rel="noopener">React中文文档</a> 中的原话：</p><blockquote><p>每个组件都有几个 “生命周期方法” ，您可以重写这些方法，以在过程中的特定时间运行代码。 前缀为 will 的方法在一些事情发生之前被调用，而前缀为 did 的方法在一些事情发生后被调用。</p></blockquote><p>这段话告诉我们三件事情：</p><ol><li>生命周期方法我们可以自己改写。</li><li>前缀是 will 的方法在一些事情发生之前被调用。</li><li>前缀为 did 的方法在一些事情发生后被调用。</li></ol><p>那组件的生命周期分为哪几个过程呢？共有三大过程：<strong>Mounting(装载)，Updating(更新)，Unmounting(卸载)</strong></p><p><strong>Mounting</strong>的意思就是一个组件实例被创建并将其插入 DOM 中；</p><p><strong>Updating</strong>的意思就是刚刚完成Mounting的这个组件实例发生了变化，比如改变了 props 或 state；</p><p><strong>Unmounting</strong>的意思就是这个组件从 DOM 中删除；</p><p>简而言之就是这三大过程，我去首次挂载这个组件，我去更新这个组件，我去卸载这个组件。<br>以下要介绍的组件的生命周期函数全都是围绕这三大过程。</p><h2 id="组件的生命周期函数"><a href="#组件的生命周期函数" class="headerlink" title="组件的生命周期函数"></a>组件的生命周期函数</h2><h3 id="当Mounting发生的时候"><a href="#当Mounting发生的时候" class="headerlink" title="当Mounting发生的时候"></a>当Mounting发生的时候</h3><p>当组件挂载发生的时候，以下函数先后触发：</p><ol><li>constructor()</li><li>componentWillMount()</li><li>render()</li><li>componentDidMount()</li></ol><h3 id="当Updating发生的时候"><a href="#当Updating发生的时候" class="headerlink" title="当Updating发生的时候"></a>当Updating发生的时候</h3><p>当组件更新发生的时候，以下函数先后触发：</p><ol><li>componentWillReceiveProps()</li><li>shouldComponentUpdate()</li><li>componentWillUpdate()</li><li>render()</li><li>componentDidUpdate()</li></ol><h3 id="当Unmounting发生的时候"><a href="#当Unmounting发生的时候" class="headerlink" title="当Unmounting发生的时候"></a>当Unmounting发生的时候</h3><p>当组件卸载发生的时候，这个函数触发：</p><ul><li>componentWillUnmount()</li></ul><p>具体的函数参数和使用可以参考 <a href="http://www.css88.com/react/docs/react-component.html#constructor" target="_blank" rel="noopener">React生命周期函数</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这些函数还是很有用的。</p><p>比如，在一个组件里要做一些后端数据请求，我们都是把请求放在<code>componentDidMount()</code>中；自定义Form组件的时候，我们经常会用到<code>componentWillReceiveProps()</code>。</p><p>当然这些是我个人的一些经验，就不展开说了。大家遇到类似需求的时候，别忘了这些好用的函数就好了。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>之后在读《深入React技术栈》这本书的时候，发现了一个描述React生命周期的很清晰的图，在这里贴一下：</p><p><img src="https://ws1.sinaimg.cn/large/0072eorIgy1fw0thfko2fj30m80ec3zq.jpg" alt="clipboard.png"></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>个人最顺手的git工作流程</title>
      <link href="/2018/10/08/%E4%B8%AA%E4%BA%BA%E6%9C%80%E9%A1%BA%E6%89%8B%E7%9A%84git%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/"/>
      <url>/2018/10/08/%E4%B8%AA%E4%BA%BA%E6%9C%80%E9%A1%BA%E6%89%8B%E7%9A%84git%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>入职满一个月了，目前我们组是使用gitlab合作开发，在这里总结了一下git的使用流程。这一套流程是我目前自己在用的，感觉还不错。</p><h3 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h3><pre><code>git clone + URL //创建本地仓库git checkout origin/dev -b dev //拉取远程dev分支到本地dev分支git checkout -b ningliu //新建自己的本地分支ningliu（ningliu是我的名字）git push --set-upstream origin ningliu //把自己的本地分支同步到远端分支git checkout ningliu //确保在自己的本地分支操作</code></pre><h3 id="每次修改完代码"><a href="#每次修改完代码" class="headerlink" title="每次修改完代码"></a>每次修改完代码</h3><pre><code>git add . //把自己的修改推送到本地index区git commit -m &quot;这里写提交的信息哦&quot; //把自己的修改推送到head区，并附加提交信息</code></pre><p>备注：不理解index区和head区等基本概念的推荐阅读 [git - 简易指南][1]。 这篇文章足够了解基本概念了。</p><h3 id="重头戏：更新到远端仓库"><a href="#重头戏：更新到远端仓库" class="headerlink" title="重头戏：更新到远端仓库"></a>重头戏：更新到远端仓库</h3><p>我是将以下代码保存成<code>git.sh</code>文件，放在项目根目录下，每次运行<code>sh git.sh</code>即可自动实现以下命令。</p><pre><code>#!/bin/shif [ $? -ne 0 ]; thenexit 1fiMAIN=&quot;dev&quot;# 将变量 ME 的值改为自己的分支名ME=&quot;branch_name&quot;git push # 把本地自己分支的修改推送到远端自己分支git pull # 拉取远端自己分支的更新git merge origin/${MAIN} # 把远端dev分支合并到本地自己分支git push # 把本地自己分支的修改推送到远端自己分支git checkout ${MAIN} # 切换到本地dev分支git pull # 拉取远端dev分支的更新git merge ${ME} # 把本地自己分支合并到本地dev分支git push # 把本地dev分支的修改推送到远端dev分支git checkout ${ME} # 切换回自己的本地分支</code></pre><p>每行命令我已经加上了注释。总之这几行命令实现了本地和远端自己的分支、本地和远端的dev分支的同步。前四行是实现自己分支的最新化，后四行是实现dev分支的最新化。</p><p>如果同步过程中遇到冲突，再自行解决。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这是我目前最顺手的git工作流程，如果有更好的实践，欢迎大家一起讨论。</p><h3 id="补充场景"><a href="#补充场景" class="headerlink" title="补充场景"></a>补充场景</h3><p>根据工作中遇到的场景越来越多，特此做一下补充：</p><h4 id="场景一：上线前需要合并master分支"><a href="#场景一：上线前需要合并master分支" class="headerlink" title="场景一：上线前需要合并master分支"></a>场景一：上线前需要合并master分支</h4><p>每次上线都要合并master，为了保证代码的新鲜度，这个时候可以用以下命令合并master分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch #下载一下远程代码</span><br><span class="line">git merge orgin/master #把master分支合并到当前分支</span><br></pre></td></tr></table></figure><h4 id="场景二：修改线上BUG"><a href="#场景二：修改线上BUG" class="headerlink" title="场景二：修改线上BUG"></a>场景二：修改线上BUG</h4><p>先在gitlab上基于master新建一个新的修改bug分支，例如master_fix<br>然后使用以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master:master_fix #拉取远程分支到本地</span><br></pre></td></tr></table></figure><p>需要修改的内容在这个分支修改就可以了。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>几张图看明白MVC MVP MVVM</title>
      <link href="/2018/10/08/%E5%87%A0%E5%BC%A0%E5%9B%BE%E7%9C%8B%E6%98%8E%E7%99%BDMVC%20MVP%20MVVM/"/>
      <url>/2018/10/08/%E5%87%A0%E5%BC%A0%E5%9B%BE%E7%9C%8B%E6%98%8E%E7%99%BDMVC%20MVP%20MVVM/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章整理于阮一峰老师的文章，我整理过来做一下学习记录，也方便有需要的朋友浏览。</p><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC由以下三部分组成：</p><p><img src="https://ws1.sinaimg.cn/large/0072eorIgy1fw0smeix2ej30e809rmx0.jpg" alt="图片描述"></p><ol><li><strong>视图（View）：</strong>用户界面</li><li><strong>控制器（Controller）：</strong>业务逻辑</li><li><strong>模型（Model）：</strong>数据保存</li></ol><p>各部分之间的通信过程如下：</p><p><img src="https://ws1.sinaimg.cn/large/0072eorIgy1fw0sme84axj30g009qglq.jpg" alt="图片描述"></p><ol><li>View 传送指令到 Controller</li><li>Controller 完成业务逻辑后，要求 Model 改变状态</li><li>Model 将新的数据发送到 View，用户得到反馈</li></ol><p>用户进行操作时，MVC可以分成两种方式。一种是通过 View 接受指令，传递给 Controller：</p><p><img src="https://ws1.sinaimg.cn/large/0072eorIgy1fw0smdbphhj30g00e0mxm.jpg" alt="图片描述"></p><p>另一种是直接通过controller接受指令：</p><p><img src="https://ws1.sinaimg.cn/large/0072eorIgy1fw0smd4vpij30fm0di74h.jpg" alt="图片描述"></p><h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p>MVP 模式将 Controller 改名为 Presenter，同时改变了通信方向：</p><p><img src="https://ws1.sinaimg.cn/large/0072eorIgy1fw0smcz7eqj30ex08zjrb.jpg" alt="图片描述"></p><ol><li>各部分之间的通信，都是双向的</li><li>View 与 Model 不发生联系，都通过 Presenter 传递</li><li>View 非常薄，不部署任何业务逻辑，称为被动视图（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里</li></ol><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致，唯一的区别是，它采用<strong>双向绑定</strong>（data-binding），View的变动，自动反映在 ViewModel，反之亦然：</p><p><img src="https://ws1.sinaimg.cn/large/0072eorIgy1fw0smcsd8wj30fg0brwef.jpg" alt="图片描述"></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Vue底层实现原理概述</title>
      <link href="/2018/10/08/Vue%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/"/>
      <url>/2018/10/08/Vue%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在研究 <a href="https://segmentfault.com/a/1190000006599500" target="_blank" rel="noopener">剖析Vue原理&amp;实现双向绑定MVVM</a> 这篇文章，一边学习一边总结一下自己的思考。</p><p>Vue是一个典型的MVVM框架，模型（Model）只是普通的JavaScript对象，修改它则视图（View）会自动更新。这种设计让状态管理变得非常简单而直观。那么Vue是如何把模型和视图建立起关联的呢？</p><h2 id="实现原理概述"><a href="#实现原理概述" class="headerlink" title="实现原理概述"></a>实现原理概述</h2><p>这是前言提到的文章里的代码，一段典型的体现了Vue特点的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"mvvm-app"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> v-model=<span class="string">"word"</span>&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;word&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button v-on:click="sayHi"&gt;change model&lt;/</span>button&gt; <span class="comment">//点击这个button，word的值会发生改变</span></span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script src="./</span>js/observer.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;script src="</span>./js/watcher.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;script src="</span>./js/compile.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;script src="</span>./js/mvvm.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">    var vm = new MVVM(&#123;</span></span><br><span class="line"><span class="string">        el: '#mvvm-app',</span></span><br><span class="line"><span class="string">        data: &#123;</span></span><br><span class="line"><span class="string">            word: 'Hello World!'</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        methods: &#123;</span></span><br><span class="line"><span class="string">            sayHi: function() &#123;</span></span><br><span class="line"><span class="string">                this.word = 'Hi, everybody!';</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>Vue实现这种数据双向绑定的效果，需要三大模块：</p><ol><li><p><strong>Observer</strong>：能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者</p></li><li><p><strong>Compile</strong>：对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数</p></li><li><p><strong>Watcher</strong>：作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图</p></li></ol><h2 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h2><p>Observer的核心是通过<code>Obeject.defineProperty()</code>来监听数据的变动，这个函数内部可以定义<code>setter</code>和<code>getter</code>，每当数据发生变化，就会触发<code>setter</code>。这时候<code>Observer</code>就要通知订阅者，订阅者就是<code>Watcher</code>。</p><h2 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h2><p><code>Watcher</code>订阅者作为<code>Observer</code>和<code>Compile</code>之间通信的桥梁，主要做的事情是：</p><ol><li>在自身实例化时往属性订阅器(dep)里面添加自己</li><li>自身必须有一个<code>update()</code>方法</li><li>待属性变动<code>dep.notice()</code>通知时，能调用自身的update()方法，并触发<code>Compile</code>中绑定的回调</li></ol><h2 id="Compile"><a href="#Compile" class="headerlink" title="Compile"></a>Compile</h2><p><code>Compile</code>主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于每部分具体的代码实现，可以参阅 <a href="https://segmentfault.com/a/1190000006599500" target="_blank" rel="noopener">剖析Vue原理&amp;实现双向绑定MVVM</a> 这篇文章，这篇文章写得非常好。我打算研究透彻之后自己实现一下简易的Vue框架。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>如果你还搞不懂HTTP报文</title>
      <link href="/2018/10/08/%E5%A6%82%E6%9E%9C%E4%BD%A0%E8%BF%98%E6%90%9E%E4%B8%8D%E6%87%82HTTP%E6%8A%A5%E6%96%87/"/>
      <url>/2018/10/08/%E5%A6%82%E6%9E%9C%E4%BD%A0%E8%BF%98%E6%90%9E%E4%B8%8D%E6%87%82HTTP%E6%8A%A5%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>HTTP报文由三部分组成：</p><ol><li><strong>起始行</strong>：报文的第一行就是起始行,在请求报文中用来说明要做些什么,在响应报文中说明出现了什么情况</li><li><strong>报文头</strong>：起始行后面有零个或多个字段。每个字段都包含一个名字和一个值,为了便于解析,两者之间用冒号(:)来分隔，<strong>首部以一个空行结束</strong>。</li><li><strong>主体</strong>：空行之后就是可选的报文主体了，其中包含了所有类型的数据。请求主体是要发送给服务器的数据;响应主体是要返回给客户端的数据。起始行和报文都是文本且都是结构化的,而主体则不同,主体中可以包含任意的二进制数据(比如图片、视频)。当然,主体中也可以包含文本。</li></ol><h2 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h2><p>一个请求报文<strong>起始行</strong>的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /dir/index.html HTTP/1.1</span><br></pre></td></tr></table></figure><ul><li>GET：这里指明请求方法是GET，还有其它方法比如POST、DELETE、HEAD、OPTIONS、PUT、TRACE</li><li>/dir/index.html：这里指明URL，它和报文头的Host属性组成完整的请求URL</li><li>HTTP/1.1：这里指明协议名称及版本号</li></ul><p><strong>报文头</strong>里有很多的字段，具几个常见的例子：</p><ul><li><code>Host</code>：请求的服务器地址，比如<a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a></li><li><code>Accept</code>: 指明客户端可以接受的数据类型，比如text/html</li><li><code>Cookie</code>：携带的Cookie信息</li><li><code>Cache-Control</code>：对缓存进行控制，指明一个请求希望响应返回的内容在客户端要被缓存多久或是否缓存</li></ul><p>还有非常多的字段，可以查阅文档，例如 [HTTP MDN][1]</p><p>最后举一个<strong>请求主体</strong>的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=ning&amp;age=24</span><br></pre></td></tr></table></figure><p>这里的请求主体就是我们提交的表单里的数据。</p><h2 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h2><p>一个响应报文<strong>起始行</strong>的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure><p>跟请求报文比，响应报文的起始行里多了一个状态码来告诉客户端本次请求的处理结果。以下是状态码的类型：</p><p><img src="https://ws1.sinaimg.cn/large/0072eorIgy1fw0t0vqqghj30ko072glr.jpg" alt="状态码类型"></p><p>例如：<br>200 OK<br>303 See Other<br>304 Not Modified<br>404 Not Found<br>500 Internal Server Error </p><p>关于响应报文头里面的各种字段，可以查阅文档 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP" target="_blank" rel="noopener">HTTP MDN</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这些就是关于HTTP报文的基本知识点，其实内容最多地方是报文头里各种字段的用法，比如很多字段是用来做浏览器缓存控制的。因为涉及字段的内容太多了，更具体的字段用法可以查阅文档 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP" target="_blank" rel="noopener">HTTP MDN</a>。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>跨域问题的根本解决方案CORS</title>
      <link href="/2018/10/08/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B9%E6%9C%AC%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88CORS/"/>
      <url>/2018/10/08/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B9%E6%9C%AC%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88CORS/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>关于跨域问题有很多的解决方案，这里我们总结一下目前最通用最强大的解决方案：CORS。</p><p>W3C 的 Web 工作组推荐了一种新的机制，即跨域资源共享（Cross-origin Resource Sharing），简称CORS。其实这个机制就是实现了跨站访问控制，使得安全地进行跨站数据传输成为可能。</p><p>跨源资源共享标准( cross-origin sharing standard) 使得以下场景可以使用跨站 HTTP 请求：</p><ol><li>使用 XMLHttpRequest 或 Fetch发起跨站 HTTP 请求。</li><li>Web 字体 (CSS 中通过 @font-face 使用跨站字体资源)，因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用。</li><li>WebGL 贴图</li><li>使用drawImage绘制</li><li>Images/video 画面到canvas.</li><li>样式表（使用 CSSOM）</li><li>Scripts (for unmuted exceptions)</li></ol><p>CORS分为<strong>简单请求</strong>和<strong>复杂请求</strong>，处理方法也是有不同的，所以我们分别总结。</p><h1 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h1><p>什么是简单请求呢？同时满足以下两个条件，就是简单请求：</p><ol><li>请求是下列之一：<br><code>HEAD</code><br><code>GET</code><br><code>POST</code></li><li>HTTP的头信息不超出以下几种字段：<br><code>Accept</code><br><code>Accept-Language</code><br><code>Content-Language</code><br><code>Last-Event-ID</code><br><code>Content-Type</code>：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</li></ol><p>实现方法非常简单，只需要把服务器的响应报文里的<code>Access-Control-Allow-Origin</code>设置为<code>*</code>或者包含由 <code>Origin</code>指明的站点。</p><p><code>Access-Control-Allow-Origin</code>是<strong>HTTP响应报文</strong>中的一个字段，<code>Origin</code>是<strong>HTTP请求报文</strong>中的以一个字段,如果不清楚这两个字段的话，可以自行查阅关于<strong>HTTP报文</strong>的知识，比如<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP" target="_blank" rel="noopener">HTTP | MDN</a>。</p><h1 id="复杂请求"><a href="#复杂请求" class="headerlink" title="复杂请求"></a>复杂请求</h1><p>如果不是简单请求，那就是复杂请求，比如请求的方法是<code>PUT</code>或者<code>DELETE</code>，比如<code>Content-Type</code>字段的类型是application/json，比如设置了自定义头信息。</p><p>复杂请求就是比简单请求多了个预检请求（preflight）而已。</p><p>预检请求就是浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。</p><p>预检请求用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字段是<code>Origin</code>，表示请求来自哪个源。除了<code>Origin</code>字段，还有两个字段非常重要：<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>，分别表示允许的请求方法和请求头。</p><p>举一个具体的例子：</p><p>现在，我们有一个页面向服务器发送了一个<code>POST</code>请求，并且我们自己定义了一个请求头字段<code>My-HEADER</code>，这时候浏览器就会首先发送一个<code>OPTION</code>请求来做预检请求，请求头里有以下字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Request-Method: POST</span><br><span class="line">Access-Control-Request-Headers: My-HEADER</span><br></pre></td></tr></table></figure><p>如果预检请求成功的话，响应头里的内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://example.com //表明服务器允许http://example.com的请求</span><br><span class="line">Access-Control-Allow-Methods: POST, GET, OPTIONS //表明服务器可以接受POST, GET和 OPTIONS的请求方法</span><br><span class="line">Access-Control-Allow-Headers: My-HEADER //传递一个可接受的自定义请求头列表</span><br><span class="line">Access-Control-Max-Age: 3000000 //告诉浏览器，本次预检请求的响应结果有效时间是多久</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是CORS方法解决跨域问题的流程，CORS支持所有类型的HTTP请求，是目前跨域问题的根本解决方案。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>什么是跨域以及几种简单解决方案</title>
      <link href="/2018/10/08/%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%E4%BB%A5%E5%8F%8A%E5%87%A0%E7%A7%8D%E7%AE%80%E5%8D%95%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2018/10/08/%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%E4%BB%A5%E5%8F%8A%E5%87%A0%E7%A7%8D%E7%AE%80%E5%8D%95%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a>什么是跨域？</h1><p>要明白什么是跨域之前，首先要明白什么是<strong>同源策略</strong>？</p><p>同源策略就是用来限制从一个源加载的文档或脚本与来自另一个源的资源进行交互。那怎样判断是否是同源呢？</p><p>如果协议，端口（如果指定了）和主机对于两个页面是相同的，则两个页面具有相同的源，也就是同源。也就是说，要同时满足以下3个条件，才能叫同源：</p><ol><li>协议相同</li><li>端口相同</li><li>主机相同</li></ol><p>举个例子就一目了然了：</p><p>我们来看下面的页面是否与 <code>http://store.company.com/dir/index.html</code> 是同源的？</p><ol><li><code>http://store.company.com/dir/index2.html</code>   同源 </li><li><code>http://store.company.com/dir2/index3.html</code>  同源 虽然在不同文件夹下</li><li><code>https://store.company.com/secure.html</code>     不同源 不同的协议(https) </li><li><code>http://store.company.com:81/dir/index.html</code> 不同源 不同的端口(81) </li><li><code>http://news.company.com/dir/other.html</code>     不同源 不同的主机(news)</li></ol><p>所以当面对跨域问题的时候，有什么解决方案呢？</p><h1 id="跨域的几种解决方案"><a href="#跨域的几种解决方案" class="headerlink" title="跨域的几种解决方案"></a>跨域的几种解决方案</h1><h2 id="document-domain方法"><a href="#document-domain方法" class="headerlink" title="document.domain方法"></a>document.domain方法</h2><p>我们来看一个具体场景：有一个页面 <code>http://www.example.com/a.html</code> ，它里面有一个<code>iframe</code>，这个<code>iframe</code>的源是 <code>http://example.com/b.html</code> ，很显然它们是不同源的，所以我们无法在父页面中操控子页面的内容。</p><p>解决方案如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- b.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.domain = <span class="string">'example.com'</span>;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- a.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.domain = <span class="string">'example.com'</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>).contentWindow.document;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="comment">//后面就可以操作iframe里的内容了...</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以我们只要将两个页面的document.domain设置成一致就可以了，要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域。</p><p>但是，这种方法只能解决主域相同的跨域问题。</p><h2 id="window-name方法"><a href="#window-name方法" class="headerlink" title="window.name方法"></a>window.name方法</h2><p>window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。</p><p>我们来看一个具体场景，在一个页面 <code>example.com/a.html</code> 中，我们想获取 <code>data.com/data.html</code> 中的数据，以下是解决方案：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- data.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.name = <span class="string">'data'</span>; <span class="comment">//这是就是我们需要通信的数据</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- a.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">getData</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</span></span><br><span class="line"><span class="javascript">        iframe.src = <span class="string">'example.com/b.html'</span>; <span class="comment">// 这里让iframe与父页面同源</span></span></span><br><span class="line"><span class="undefined">        </span></span><br><span class="line"><span class="javascript">        iframe.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> data = iframe.contentWindow.name; <span class="comment">//在这里我们得到了跨域页面中传来的数据</span></span></span><br><span class="line"><span class="undefined">        &#125;;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="JSONP方法"><a href="#JSONP方法" class="headerlink" title="JSONP方法"></a>JSONP方法</h2><p>JONSP(JSON with Padding)是JSON的一种使用模式。基本原理如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- a.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">dealData</span> (<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(data);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'http://example.com/data.php?callback=dealData'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $callback = $_GET[<span class="string">'callback'</span>];</span><br><span class="line">    $data = <span class="string">'data'</span>;</span><br><span class="line">    <span class="keyword">echo</span> $callback.<span class="string">'('</span>.json_encode($data).<span class="string">')'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>这时候在<code>a.html</code>中我们得到了一条js的执行语句<code>dealData(&#39;data&#39;)</code>，从而达到了跨域的目的。</p><p>所以JSONP的原理其实就是利用引入<code>script</code>不限制源的特点，把处理函数名作为参数传入，然后返回执行语句，仔细阅读以上代码就可以明白里面的意思了。</p><p>如果在jQuery中用JSONP的话就更加简单了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">$.getJSON(<span class="string">''</span>http:<span class="comment">//example.com/data.php?callback=?', function (data) &#123;</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(data);</span></span><br><span class="line"><span class="undefined">&#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意jQuery会自动生成一个全局函数来替换<code>callback=?</code>中的问号，之后获取到数据后又会自动销毁，实际上就是起一个临时代理函数的作用。<code>$.getJSON</code>方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用JSONP的回调函数。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>除了上述方法外，HTML5还新增了一个<code>window.postMessage()</code>方法，有兴趣的可以自行查阅。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>JavaScript实现类与继承的方法（全面整理）</title>
      <link href="/2018/10/08/JavaScript%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E5%85%A8%E9%9D%A2%E6%95%B4%E7%90%86%EF%BC%89/"/>
      <url>/2018/10/08/JavaScript%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E5%85%A8%E9%9D%A2%E6%95%B4%E7%90%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript定义类的4种方法"><a href="#JavaScript定义类的4种方法" class="headerlink" title="JavaScript定义类的4种方法"></a>JavaScript定义类的4种方法</h1><h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">creatPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line">obj.name = name;</span><br><span class="line">obj.age = age;</span><br><span class="line"></span><br><span class="line">obj.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">window</span>.alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">            </span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数方法"><a href="#构造函数方法" class="headerlink" title="构造函数方法"></a>构造函数方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">window</span>.alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原型方法"><a href="#原型方法" class="headerlink" title="原型方法"></a>原型方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line"><span class="keyword">constructor</span> : Person,</span><br><span class="line">name : "Ning",</span><br><span class="line">age : "23",</span><br><span class="line">sayName : function() &#123;</span><br><span class="line"><span class="built_in">window</span>.alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>大家可以看到这种方法有缺陷，类里属性的值都是在原型里给定的。</p><h2 id="组合使用构造函数和原型方法（使用最广）"><a href="#组合使用构造函数和原型方法（使用最广）" class="headerlink" title="组合使用构造函数和原型方法（使用最广）"></a>组合使用构造函数和原型方法（使用最广）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line"><span class="keyword">constructor</span> : Person, </span><br><span class="line">sayName : function() &#123;</span><br><span class="line"><span class="built_in">window</span>.alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将构造函数方法和原型方法结合使用是目前最常用的定义类的方法。这种方法的好处是实现了属性定义和方法定义的分离。比如我可以创建两个对象<code>person1</code>和<code>person2</code>，它们分别传入各自的<code>name</code>值和<code>age</code>值，但<code>sayName()</code>方法可以同时使用原型里定义的。</p><h1 id="JavaScript实现继承的3种方法"><a href="#JavaScript实现继承的3种方法" class="headerlink" title="JavaScript实现继承的3种方法"></a>JavaScript实现继承的3种方法</h1><h2 id="借用构造函数法（又叫经典继承）"><a href="#借用构造函数法（又叫经典继承）" class="headerlink" title="借用构造函数法（又叫经典继承）"></a>借用构造函数法（又叫经典继承）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">window</span>.alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">SuperType.call(<span class="keyword">this</span>, name); <span class="comment">//在这里借用了父类的构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象冒充"><a href="#对象冒充" class="headerlink" title="对象冒充"></a>对象冒充</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">window</span>.alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.supertype = SuperType; <span class="comment">//在这里使用了对象冒充</span></span><br><span class="line"><span class="keyword">this</span>.supertype(name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合继承（最常用）"><a href="#组合继承（最常用）" class="headerlink" title="组合继承（最常用）"></a>组合继承（最常用）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype = &#123;</span><br><span class="line"></span><br><span class="line">    sayName : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">window</span>.alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">SuperType.call(<span class="keyword">this</span>, name); <span class="comment">//在这里继承属性</span></span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); <span class="comment">//这里继承方法</span></span><br></pre></td></tr></table></figure><p>组合继承的方法是对应着我们用‘组合使用构造函数和原型方法’定义父类的一种继承方法。同样的，我们的属性和方法是分开继承的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是常见的JavaScript中面向对象编程的几种实现，欢迎大家补充与指正。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>为什么要使用闭包和如何使用闭包</title>
      <link href="/2018/10/07/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85%E5%92%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85/"/>
      <url>/2018/10/07/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85%E5%92%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>JS中的闭包是一个我们经常遇到的名词，到底什么是闭包？为什么我们要使用闭包？又该如何使用闭包呢？</p><h2 id="为什么我们需要闭包"><a href="#为什么我们需要闭包" class="headerlink" title="为什么我们需要闭包"></a>为什么我们需要闭包</h2><p>首先来看一个例子，我们来实现一个计数器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> counter += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line">add();<span class="comment">// 计数器现在为 3</span></span><br></pre></td></tr></table></figure><p>现在我们已经达到了目的，可是问题来了，代码中的任何一个函数都可以随意改变<code>counter</code>的值，所以这个计数器并不完美。那我们把<code>counter</code>放在<code>add</code>函数里面不就好了么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> counter += <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line">add();<span class="comment">// 本意是想输出 3, 但输出的都是 1</span></span><br></pre></td></tr></table></figure><p>所以这样做的话，每次调用<code>add</code>函数，<code>counter</code>的值都要被初始化为0，还是达不到我们的目的。</p><h2 id="如何使用闭包"><a href="#如何使用闭包" class="headerlink" title="如何使用闭包"></a>如何使用闭包</h2><p>所以这时候我们就要用闭包去解决这个问题了，先看代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">return</span> counter += <span class="number">1</span>;&#125;</span><br><span class="line">&#125;)();</span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line">add();<span class="comment">// 计数器为 3</span></span><br></pre></td></tr></table></figure><p>这时候我们完美实现了计数器。这段非常精简，可以拆分成如下等价代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> counter += <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> innerFunction;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> add = outerFunction();</span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line">add();<span class="comment">// 计数器为 3</span></span><br></pre></td></tr></table></figure><p>这时候的<code>add</code>就形成了一个闭包。一个闭包由两部分组成，函数和创建该函数的环境。环境是由环境中的局部变量组成的。对于闭包<code>add</code>来说，它由函数<code>innerFunction</code>和变量<code>counter</code>组成，所以这时候<code>add</code>是可以访问变量<code>counter</code>的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以闭包的功能就是使一个函数能访问另一个函数作用域中的变量。形成闭包之后，该变量不会被垃圾回收机制回收。</p><p>闭包的原理其实还是作用域。</p><p>使用闭包的优点是可以避免全局变量污染，缺点是容易造成内存泄露。 </p>]]></content>
      
      
      
    </entry>
    
  
  
</search>
