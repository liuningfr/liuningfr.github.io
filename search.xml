<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>跨域问题的根本解决方案CORS</title>
      <link href="/2018/10/08/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B9%E6%9C%AC%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88CORS/"/>
      <url>/2018/10/08/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B9%E6%9C%AC%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88CORS/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>关于跨域问题有很多的解决方案，这里我们总结一下目前最通用最强大的解决方案：CORS。</p><p>W3C 的 Web 工作组推荐了一种新的机制，即跨域资源共享（Cross-origin Resource Sharing），简称CORS。其实这个机制就是实现了跨站访问控制，使得安全地进行跨站数据传输成为可能。</p><p>跨源资源共享标准( cross-origin sharing standard) 使得以下场景可以使用跨站 HTTP 请求：</p><ol><li>使用 XMLHttpRequest 或 Fetch发起跨站 HTTP 请求。</li><li>Web 字体 (CSS 中通过 @font-face 使用跨站字体资源)，因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用。</li><li>WebGL 贴图</li><li>使用drawImage绘制</li><li>Images/video 画面到canvas.</li><li>样式表（使用 CSSOM）</li><li>Scripts (for unmuted exceptions)</li></ol><p>CORS分为<strong>简单请求</strong>和<strong>复杂请求</strong>，处理方法也是有不同的，所以我们分别总结。</p><h1 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h1><p>什么是简单请求呢？同时满足以下两个条件，就是简单请求：</p><ol><li>请求是下列之一：<br><code>HEAD</code><br><code>GET</code><br><code>POST</code></li><li>HTTP的头信息不超出以下几种字段：<br><code>Accept</code><br><code>Accept-Language</code><br><code>Content-Language</code><br><code>Last-Event-ID</code><br><code>Content-Type</code>：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</li></ol><p>实现方法非常简单，只需要把服务器的响应报文里的<code>Access-Control-Allow-Origin</code>设置为<code>*</code>或者包含由 <code>Origin</code>指明的站点。</p><p><code>Access-Control-Allow-Origin</code>是<strong>HTTP响应报文</strong>中的一个字段，<code>Origin</code>是<strong>HTTP请求报文</strong>中的以一个字段,如果不清楚这两个字段的话，可以自行查阅关于<strong>HTTP报文</strong>的知识，比如<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP" target="_blank" rel="noopener">HTTP | MDN</a>。</p><h1 id="复杂请求"><a href="#复杂请求" class="headerlink" title="复杂请求"></a>复杂请求</h1><p>如果不是简单请求，那就是复杂请求，比如请求的方法是<code>PUT</code>或者<code>DELETE</code>，比如<code>Content-Type</code>字段的类型是application/json，比如设置了自定义头信息。</p><p>复杂请求就是比简单请求多了个预检请求（preflight）而已。</p><p>预检请求就是浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。</p><p>预检请求用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字段是<code>Origin</code>，表示请求来自哪个源。除了<code>Origin</code>字段，还有两个字段非常重要：<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>，分别表示允许的请求方法和请求头。</p><p>举一个具体的例子：</p><p>现在，我们有一个页面向服务器发送了一个<code>POST</code>请求，并且我们自己定义了一个请求头字段<code>My-HEADER</code>，这时候浏览器就会首先发送一个<code>OPTION</code>请求来做预检请求，请求头里有以下字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Request-Method: POST</span><br><span class="line">Access-Control-Request-Headers: My-HEADER</span><br></pre></td></tr></table></figure><p>如果预检请求成功的话，响应头里的内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://example.com //表明服务器允许http://example.com的请求</span><br><span class="line">Access-Control-Allow-Methods: POST, GET, OPTIONS //表明服务器可以接受POST, GET和 OPTIONS的请求方法</span><br><span class="line">Access-Control-Allow-Headers: My-HEADER //传递一个可接受的自定义请求头列表</span><br><span class="line">Access-Control-Max-Age: 3000000 //告诉浏览器，本次预检请求的响应结果有效时间是多久</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是CORS方法解决跨域问题的流程，CORS支持所有类型的HTTP请求，是目前跨域问题的根本解决方案。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>什么是跨域以及几种简单解决方案</title>
      <link href="/2018/10/08/%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%E4%BB%A5%E5%8F%8A%E5%87%A0%E7%A7%8D%E7%AE%80%E5%8D%95%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2018/10/08/%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%E4%BB%A5%E5%8F%8A%E5%87%A0%E7%A7%8D%E7%AE%80%E5%8D%95%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a>什么是跨域？</h1><p>要明白什么是跨域之前，首先要明白什么是<strong>同源策略</strong>？</p><p>同源策略就是用来限制从一个源加载的文档或脚本与来自另一个源的资源进行交互。那怎样判断是否是同源呢？</p><p>如果协议，端口（如果指定了）和主机对于两个页面是相同的，则两个页面具有相同的源，也就是同源。也就是说，要同时满足以下3个条件，才能叫同源：</p><ol><li>协议相同</li><li>端口相同</li><li>主机相同</li></ol><p>举个例子就一目了然了：</p><p>我们来看下面的页面是否与 <code>http://store.company.com/dir/index.html</code> 是同源的？</p><ol><li><code>http://store.company.com/dir/index2.html</code>   同源 </li><li><code>http://store.company.com/dir2/index3.html</code>  同源 虽然在不同文件夹下</li><li><code>https://store.company.com/secure.html</code>     不同源 不同的协议(https) </li><li><code>http://store.company.com:81/dir/index.html</code> 不同源 不同的端口(81) </li><li><code>http://news.company.com/dir/other.html</code>     不同源 不同的主机(news)</li></ol><p>所以当面对跨域问题的时候，有什么解决方案呢？</p><h1 id="跨域的几种解决方案"><a href="#跨域的几种解决方案" class="headerlink" title="跨域的几种解决方案"></a>跨域的几种解决方案</h1><h2 id="document-domain方法"><a href="#document-domain方法" class="headerlink" title="document.domain方法"></a>document.domain方法</h2><p>我们来看一个具体场景：有一个页面 <code>http://www.example.com/a.html</code> ，它里面有一个<code>iframe</code>，这个<code>iframe</code>的源是 <code>http://example.com/b.html</code> ，很显然它们是不同源的，所以我们无法在父页面中操控子页面的内容。</p><p>解决方案如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- b.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.domain = <span class="string">'example.com'</span>;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- a.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.domain = <span class="string">'example.com'</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>).contentWindow.document;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="comment">//后面就可以操作iframe里的内容了...</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以我们只要将两个页面的document.domain设置成一致就可以了，要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域。</p><p>但是，这种方法只能解决主域相同的跨域问题。</p><h2 id="window-name方法"><a href="#window-name方法" class="headerlink" title="window.name方法"></a>window.name方法</h2><p>window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。</p><p>我们来看一个具体场景，在一个页面 <code>example.com/a.html</code> 中，我们想获取 <code>data.com/data.html</code> 中的数据，以下是解决方案：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- data.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.name = <span class="string">'data'</span>; <span class="comment">//这是就是我们需要通信的数据</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- a.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">getData</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</span></span><br><span class="line"><span class="javascript">        iframe.src = <span class="string">'example.com/b.html'</span>; <span class="comment">// 这里让iframe与父页面同源</span></span></span><br><span class="line"><span class="undefined">        </span></span><br><span class="line"><span class="javascript">        iframe.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> data = iframe.contentWindow.name; <span class="comment">//在这里我们得到了跨域页面中传来的数据</span></span></span><br><span class="line"><span class="undefined">        &#125;;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="JSONP方法"><a href="#JSONP方法" class="headerlink" title="JSONP方法"></a>JSONP方法</h2><p>JONSP(JSON with Padding)是JSON的一种使用模式。基本原理如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- a.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">dealData</span> (<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(data);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'http://example.com/data.php?callback=dealData'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $callback = $_GET[<span class="string">'callback'</span>];</span><br><span class="line">    $data = <span class="string">'data'</span>;</span><br><span class="line">    <span class="keyword">echo</span> $callback.<span class="string">'('</span>.json_encode($data).<span class="string">')'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>这时候在<code>a.html</code>中我们得到了一条js的执行语句<code>dealData(&#39;data&#39;)</code>，从而达到了跨域的目的。</p><p>所以JSONP的原理其实就是利用引入<code>script</code>不限制源的特点，把处理函数名作为参数传入，然后返回执行语句，仔细阅读以上代码就可以明白里面的意思了。</p><p>如果在jQuery中用JSONP的话就更加简单了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">$.getJSON(<span class="string">''</span>http:<span class="comment">//example.com/data.php?callback=?', function (data) &#123;</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(data);</span></span><br><span class="line"><span class="undefined">&#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意jQuery会自动生成一个全局函数来替换<code>callback=?</code>中的问号，之后获取到数据后又会自动销毁，实际上就是起一个临时代理函数的作用。<code>$.getJSON</code>方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用JSONP的回调函数。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>除了上述方法外，HTML5还新增了一个<code>window.postMessage()</code>方法，有兴趣的可以自行查阅。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>JavaScript实现类与继承的方法（全面整理）</title>
      <link href="/2018/10/08/JavaScript%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E5%85%A8%E9%9D%A2%E6%95%B4%E7%90%86%EF%BC%89/"/>
      <url>/2018/10/08/JavaScript%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E5%85%A8%E9%9D%A2%E6%95%B4%E7%90%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript定义类的4种方法"><a href="#JavaScript定义类的4种方法" class="headerlink" title="JavaScript定义类的4种方法"></a>JavaScript定义类的4种方法</h1><h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">creatPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line">obj.name = name;</span><br><span class="line">obj.age = age;</span><br><span class="line"></span><br><span class="line">obj.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">window</span>.alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">            </span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数方法"><a href="#构造函数方法" class="headerlink" title="构造函数方法"></a>构造函数方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">window</span>.alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原型方法"><a href="#原型方法" class="headerlink" title="原型方法"></a>原型方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line"><span class="keyword">constructor</span> : Person,</span><br><span class="line">name : "Ning",</span><br><span class="line">age : "23",</span><br><span class="line">sayName : function() &#123;</span><br><span class="line"><span class="built_in">window</span>.alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>大家可以看到这种方法有缺陷，类里属性的值都是在原型里给定的。</p><h2 id="组合使用构造函数和原型方法（使用最广）"><a href="#组合使用构造函数和原型方法（使用最广）" class="headerlink" title="组合使用构造函数和原型方法（使用最广）"></a>组合使用构造函数和原型方法（使用最广）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line"><span class="keyword">constructor</span> : Person, </span><br><span class="line">sayName : function() &#123;</span><br><span class="line"><span class="built_in">window</span>.alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将构造函数方法和原型方法结合使用是目前最常用的定义类的方法。这种方法的好处是实现了属性定义和方法定义的分离。比如我可以创建两个对象<code>person1</code>和<code>person2</code>，它们分别传入各自的<code>name</code>值和<code>age</code>值，但<code>sayName()</code>方法可以同时使用原型里定义的。</p><h1 id="JavaScript实现继承的3种方法"><a href="#JavaScript实现继承的3种方法" class="headerlink" title="JavaScript实现继承的3种方法"></a>JavaScript实现继承的3种方法</h1><h2 id="借用构造函数法（又叫经典继承）"><a href="#借用构造函数法（又叫经典继承）" class="headerlink" title="借用构造函数法（又叫经典继承）"></a>借用构造函数法（又叫经典继承）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">window</span>.alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">SuperType.call(<span class="keyword">this</span>, name); <span class="comment">//在这里借用了父类的构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象冒充"><a href="#对象冒充" class="headerlink" title="对象冒充"></a>对象冒充</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">window</span>.alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.supertype = SuperType; <span class="comment">//在这里使用了对象冒充</span></span><br><span class="line"><span class="keyword">this</span>.supertype(name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合继承（最常用）"><a href="#组合继承（最常用）" class="headerlink" title="组合继承（最常用）"></a>组合继承（最常用）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype = &#123;</span><br><span class="line"></span><br><span class="line">    sayName : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">window</span>.alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">SuperType.call(<span class="keyword">this</span>, name); <span class="comment">//在这里继承属性</span></span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); <span class="comment">//这里继承方法</span></span><br></pre></td></tr></table></figure><p>组合继承的方法是对应着我们用‘组合使用构造函数和原型方法’定义父类的一种继承方法。同样的，我们的属性和方法是分开继承的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是常见的JavaScript中面向对象编程的几种实现，欢迎大家补充与指正。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>为什么要使用闭包和如何使用闭包</title>
      <link href="/2018/10/07/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85%E5%92%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85/"/>
      <url>/2018/10/07/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85%E5%92%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>JS中的闭包是一个我们经常遇到的名词，到底什么是闭包？为什么我们要使用闭包？又该如何使用闭包呢？</p><h2 id="为什么我们需要闭包"><a href="#为什么我们需要闭包" class="headerlink" title="为什么我们需要闭包"></a>为什么我们需要闭包</h2><p>首先来看一个例子，我们来实现一个计数器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> counter += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line">add();<span class="comment">// 计数器现在为 3</span></span><br></pre></td></tr></table></figure><p>现在我们已经达到了目的，可是问题来了，代码中的任何一个函数都可以随意改变<code>counter</code>的值，所以这个计数器并不完美。那我们把<code>counter</code>放在<code>add</code>函数里面不就好了么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> counter += <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line">add();<span class="comment">// 本意是想输出 3, 但输出的都是 1</span></span><br></pre></td></tr></table></figure><p>所以这样做的话，每次调用<code>add</code>函数，<code>counter</code>的值都要被初始化为0，还是达不到我们的目的。</p><h2 id="如何使用闭包"><a href="#如何使用闭包" class="headerlink" title="如何使用闭包"></a>如何使用闭包</h2><p>所以这时候我们就要用闭包去解决这个问题了，先看代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">return</span> counter += <span class="number">1</span>;&#125;</span><br><span class="line">&#125;)();</span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line">add();<span class="comment">// 计数器为 3</span></span><br></pre></td></tr></table></figure><p>这时候我们完美实现了计数器。这段非常精简，可以拆分成如下等价代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> counter += <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> innerFunction;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> add = outerFunction();</span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line">add();<span class="comment">// 计数器为 3</span></span><br></pre></td></tr></table></figure><p>这时候的<code>add</code>就形成了一个闭包。一个闭包由两部分组成，函数和创建该函数的环境。环境是由环境中的局部变量组成的。对于闭包<code>add</code>来说，它由函数<code>innerFunction</code>和变量<code>counter</code>组成，所以这时候<code>add</code>是可以访问变量<code>counter</code>的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以闭包的功能就是使一个函数能访问另一个函数作用域中的变量。形成闭包之后，该变量不会被垃圾回收机制回收。</p><p>闭包的原理其实还是作用域。</p><p>使用闭包的优点是可以避免全局变量污染，缺点是容易造成内存泄露。 </p>]]></content>
      
      
      
    </entry>
    
  
  
</search>
