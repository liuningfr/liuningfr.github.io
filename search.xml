<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>从超长文本显示谈起的一些废话</title>
      <link href="/2019/07/25/%E8%B6%85%E9%95%BF%E6%96%87%E6%9C%AC%E6%98%BE%E7%A4%BA/"/>
      <url>/2019/07/25/%E8%B6%85%E9%95%BF%E6%96%87%E6%9C%AC%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在做面向C端用户的小程序项目的我一直遇到超长文本需要显示省略号的问题…</p><p>例如下图</p><p><img src="http://tva1.sinaimg.cn/large/0060lm7Tly1g5c3kr3nkgj30ki0diq69.jpg" width="385" height="300" alt="图片名称"></p><p>C端产品中类似的场景会非常多，毕竟你永远无法保证用户会输入什么鬼东西。如果不做超长文本的处理，那界面就会变成这样子…</p><p><img src="http://tva1.sinaimg.cn/large/0060lm7Tly1g5c3ue1zfij30ka0g679c.jpg" width="385" height="300" alt="图片名称"></p><p>如果显示成这样，不仅自己看着难受，UI同学也不会放过我。</p><p>所以怎样处理超长文本的显示呢？</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>脑海中第一反应是<code>text-overflow: ellipsis</code>，这种处理没毛病，但是多行的超长文本，比如上图的例子？</p><p>网上的标准代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">overflow: hidden;</span><br><span class="line">display: -webkit-box;</span><br><span class="line">-webkit-line-clamp: 2;</span><br><span class="line">-webkit-box-orient: vertical;</span><br></pre></td></tr></table></figure><p>这四行<code>CSS</code>就完美解决了上述问题，那这篇文章就该结束了吧…没耐心继续看的同学看到这里就已经可以解决问题了，如果不明白为什么这么写的可以继续看下去…</p><h2 id="Flex-Box"><a href="#Flex-Box" class="headerlink" title="Flex Box"></a>Flex Box</h2><p>关于<code>overflow: hidden</code>非常容易理解，可以下面三行是什么意思？怎么从来没用过？</p><p>于是我仔细查了关于<code>display: box</code>的内容，不查不知道，一查就为我开启了新世界的大门。</p><p>其实这涉及到了<code>CSS3</code>中的一种盒模型<code>box-flex</code>，不同于我们最常使用的<code>flex</code>布局，<code>box-flex</code>布局一直没有被<code>CSS</code>纳入标准，使用的时候也不得不加上<code>-webkit</code>或者<code>-moz</code>等前缀。（本文浏览器默认为Chrome，所以代码中只会加<code>-webkit</code>）</p><h3 id="box-orient"><a href="#box-orient" class="headerlink" title="box-orient"></a>box-orient</h3><p>可选值：<code>horizontal</code> | <code>vertical</code></p><p>上述代码中的<code>box-orient</code>是用来表示父容器的子容器的排练方式是水平排列(<code>horizontal</code>)还是竖直排列(<code>vertical</code>)，如下图：</p><p><code>box-orient: horizontal</code><br><img src="http://tva1.sinaimg.cn/large/0060lm7Tly1g5c5swkbzdj30i406w74b.jpg" width="300" height="100" alt="图片名称"></p><p><code>box-orient: vertical</code><br><img src="http://tva1.sinaimg.cn/large/0060lm7Tly1g5c5tzznovj306k0huaa4.jpg" width="100" height="300" alt="图片名称"></p><h3 id="line-clamp"><a href="#line-clamp" class="headerlink" title="line-clamp"></a>line-clamp</h3><p>可选值： <code>none</code> | 任意数字</p><p>这个属性用来显示容器中最多显示的行数。如果需要做最多显示3行的超长文本，就可以设置<code>line-clamp: 3</code>。默认值是<code>none</code>,表示不限制行数。</p><h3 id="box-direction"><a href="#box-direction" class="headerlink" title="box-direction"></a>box-direction</h3><p>可选值：<code>normal</code> | <code>reverse</code></p><p>默认值是<code>normal</code>,表示子元素按照文档流中正常的顺序排列；如果设置<code>box-direction: reverse</code>,表示子元素倒序排列，如下图：</p><p><code>box-direction: reverse</code><br><img src="http://tva1.sinaimg.cn/large/0060lm7Tly1g5c77mlpraj308w03cwec.jpg" width="300" height="100" alt="图片名称"></p><h3 id="box-align"><a href="#box-align" class="headerlink" title="box-align"></a>box-align</h3><p>可选值： <code>start</code> | <code>end</code> | <code>center</code> | <code>stretch</code></p><p>这个属性用来表示子元素在父容器中的垂直排列方式。</p><p><code>box-align: start</code>表示靠顶部对齐<br><img src="http://tva1.sinaimg.cn/large/0060lm7Tly1g5c7lnomy5j308w0620sm.jpg" width="300" height="200" alt="图片名称"></p><p><code>box-align: end</code>表示靠底部对齐<br><img src="http://tva1.sinaimg.cn/large/0060lm7Tly1g5c7ls8n1qj308q0640sm.jpg" width="300" height="200" alt="图片名称"></p><p><code>box-align: center</code>表示居中对齐<br><img src="http://tva1.sinaimg.cn/large/0060lm7Tly1g5c7lxe51yj308s0623ye.jpg" width="300" height="200" alt="图片名称"></p><p><code>box-align: stretch</code>表示子元素拉伸到与父元素等高<br><img src="http://tva1.sinaimg.cn/large/0060lm7Tly1g5c7m0j1u9j308w0650sm.jpg" width="300" height="200" alt="图片名称"></p><h3 id="box-pack"><a href="#box-pack" class="headerlink" title="box-pack"></a>box-pack</h3><p>可选值： <code>start</code> | <code>end</code> | <code>center</code> | <code>justify</code></p><p>这个属性用来表示子元素在父容器中的水平排列方式。</p><p><code>box-pack: start</code>表示靠左对齐<br><img src="http://tva1.sinaimg.cn/large/0060lm7Tly1g5c7rgf2frj30bp03ba9x.jpg" width="400" height="100" alt="图片名称"></p><p><code>box-pack: end</code>表示靠右对齐<br><img src="http://tva1.sinaimg.cn/large/0060lm7Tly1g5c7rjyp99j30bq03ca9x.jpg" width="400" height="100" alt="图片名称"></p><p><code>box-pack: center</code>表示居中对齐<br><img src="http://tva1.sinaimg.cn/large/0060lm7Tly1g5c7spsawjj30bn037a9x.jpg" width="400" height="100" alt="图片名称"></p><p><code>box-pack: stretch</code>表示等分父元素的宽度对齐<br><img src="http://tva1.sinaimg.cn/large/0060lm7Tly1g5c7rpyeroj30bg037745.jpg" width="400" height="100" alt="图片名称"></p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>其实看到这里大家已经发现了，<code>box-flex</code>特别像我们每天都在使用的<code>flex</code>布局，但是身世可怜的它并没有被<code>CSS</code>的主流标准接受，但是也是<code>CSS3</code>的世界中的一部分，至少在处理多行超长文本显示的时候，还会被人们想起。</p><p>本文完，如有问题，欢迎指正。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>React 中富文本编辑器的技术选型调研</title>
      <link href="/2018/12/12/React%E4%B8%AD%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E8%B0%83%E7%A0%94/"/>
      <url>/2018/12/12/React%E4%B8%AD%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>富文本编辑器是项目中不可或缺的部分，目前市面上可以选择的富文本编辑器种类繁多，如何在项目中选择一款集轻量，美观，稳定，坑少，满足需求的富文本编辑器变成了团队中一个重要的问题。</p><p>现在项目中使用的是 WangEditor，为了寻找到更好的替代品，我针对 Ant Design 官方推荐的两款的富文本编辑器做了调研。Ant Design 称它们为“社区精选组件”，在心理层面上觉得应该会比较稳定，尤其是结合 Ant Design 使用。</p><p>我对这两款富文本编辑器都进行了使用，并结合目前的项目需求进行了比较。下面是我的使用体验。</p><h2 id="react-quill"><a href="#react-quill" class="headerlink" title="react-quill"></a>react-quill</h2><p>第一款富文本编辑器叫作 react-quill，是国外一个社区维护的，贡献者有二三十人。quill 在英文中是鹅毛笔的意思，听起来还是很有美感的。<a href="https://zenoamaro.github.io/react-quill/" target="_blank" rel="noopener">点击这里查看 demo</a></p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>下面是 react-quill 的最基本的用法，非常简单。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactQuill <span class="keyword">from</span> <span class="string">'react-quill'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'react-quill/dist/quill.snow.css'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">text</span>: <span class="string">''</span> &#125;</span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">text</span>: value &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ReactQuill value=&#123;<span class="keyword">this</span>.state.text&#125; onChange=&#123;<span class="keyword">this</span>.handleChange&#125; /&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="自定义工具栏"><a href="#自定义工具栏" class="headerlink" title="自定义工具栏"></a>自定义工具栏</h3><p>核心就是配置<code>modules</code>和 <code>formats</code>。<code>modules</code>是配置工具栏上的内容，即决定工具栏上有什么；<code>formats</code>是决定哪些工具栏选项可以启用，即决定工具栏的哪些可以生效。实例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      text: <span class="string">''</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modules = &#123;</span><br><span class="line">    toolbar: [</span><br><span class="line">      [&#123; <span class="string">'header'</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="literal">false</span>] &#125;],</span><br><span class="line">      [<span class="string">'bold'</span>, <span class="string">'italic'</span>, <span class="string">'underline'</span>,<span class="string">'strike'</span>, <span class="string">'blockquote'</span>],</span><br><span class="line">      [&#123;<span class="string">'list'</span>: <span class="string">'ordered'</span>&#125;, &#123;<span class="string">'list'</span>: <span class="string">'bullet'</span>&#125;, &#123;<span class="string">'indent'</span>: <span class="string">'-1'</span>&#125;, &#123;<span class="string">'indent'</span>: <span class="string">'+1'</span>&#125;],</span><br><span class="line">      [<span class="string">'link'</span>, <span class="string">'image'</span>],</span><br><span class="line">      [<span class="string">'clean'</span>]</span><br><span class="line">    ],</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  formats = [</span><br><span class="line">    <span class="string">'header'</span>,</span><br><span class="line">    <span class="string">'bold'</span>, <span class="string">'italic'</span>, <span class="string">'underline'</span>, <span class="string">'strike'</span>, <span class="string">'blockquote'</span>,</span><br><span class="line">    <span class="string">'list'</span>, <span class="string">'bullet'</span>, <span class="string">'indent'</span>,</span><br><span class="line">    <span class="string">'link'</span>, <span class="string">'image'</span></span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"text-editor"</span>&gt;</span><br><span class="line">        &lt;ReactQuill modules=&#123;<span class="keyword">this</span>.modules&#125; formats=&#123;<span class="keyword">this</span>.formats&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>这里还有更高级的用法，我们可以在工具栏上加入自己设计的JXS元素，但是目前的项目需求用不到，这里就不展开了。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ol><li>简洁美观大方。</li><li>对于用户从各种地方粘贴过来的文字兼容得很好，不管你之前带有什么奇奇怪怪的格式，统统转化成了带有<code>&lt;p&gt;&lt;/p&gt;</code>标签的的文本。</li><li>跟 Ant Design 和 React 的融入度非常高，可以很方便的放在<code>&lt;Form&gt;&lt;/Form&gt;</code>作为一个受控组件。传入的 value 就是 HTML 字符串，不需要做任何格式转换。</li></ol><h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><ol><li>图片格式是转成了base64，这跟目前项目中图片上传方式不兼容。虽然这个问题有解决方法，<a href="https://blog.csdn.net/song279811799/article/details/78847320" target="_blank" rel="noopener">React-Quill中的图片上传及显示</a>。</li><li>不支持 Excel 格式的数据。因为目前项目中使用的 WangEditor 支持表格数据，所以如果老数据中存在表格，那么替换后的表格数据显示将成为一个问题。</li></ol><h2 id="braft-editor"><a href="#braft-editor" class="headerlink" title="braft-editor"></a>braft-editor</h2><p>这是由中国人开发的个人项目，<a href="https://braft.margox.cn/" target="_blank" rel="noopener">点这里查看 demo</a>。</p><h3 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h3><p>实例代码如下，需要注意的一点是，接收的 value 不再是 HTML 字符串了，而是<code>editorState</code>格式。<br>可以通过<code>editorState.toHTML()</code>得到 HTML 字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'braft-editor/dist/index.css'</span>;</span><br><span class="line"><span class="keyword">import</span> BraftEditor <span class="keyword">from</span> <span class="string">'braft-editor'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Braft</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">editorState</span>: BraftEditor.createEditorState(<span class="literal">null</span>) &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  handleChange = <span class="function"><span class="params">editorState</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; editorStste &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;BraftEditor value=&#123;<span class="keyword">this</span>.state.editorStste&#125; onChange=&#123;<span class="keyword">this</span>.handleChange&#125;/&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义工具栏-1"><a href="#自定义工具栏-1" class="headerlink" title="自定义工具栏"></a>自定义工具栏</h3><p>通过配置属性<code>controls</code>来自定义工具栏，也可以自定义工具栏图标的文字和样式。示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> controls = [</span><br><span class="line">    <span class="string">'undo'</span>, <span class="string">'redo'</span>, <span class="string">'separator'</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        key: <span class="string">'bold'</span>, <span class="comment">// 使用key来指定控件类型</span></span><br><span class="line">        title: <span class="string">'加粗选中文字哦'</span>, <span class="comment">// 自定义控件title</span></span><br><span class="line">        text: <span class="string">'点我加粗'</span>, <span class="comment">// 使用自定义文案来代替默认图标(B)，此处也可传入jsx</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'italic'</span>, <span class="string">'underline'</span>, <span class="string">'strike-through'</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h3><ol><li>有“全屏”功能，可以全屏编辑内容，还是很炫酷的。</li><li>作者是中国人，文档清晰易读。</li></ol><h3 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h3><ol><li>图片格式转成了base64，跟目前项目中图片上传方式不兼容。</li><li>不支持 Excel 格式的数据。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这两款编辑器的稳定性和对异常文本的处理能力都强于 WangEditor，但是存在的问题是都对于表格数据不支持，所以对于老数据的显示存在风险。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>【整理】北京美食地图</title>
      <link href="/2018/10/31/%E3%80%90%E6%95%B4%E7%90%86%E3%80%91%E5%8C%97%E4%BA%AC%E7%BE%8E%E9%A3%9F%E5%9C%B0%E5%9B%BE/"/>
      <url>/2018/10/31/%E3%80%90%E6%95%B4%E7%90%86%E3%80%91%E5%8C%97%E4%BA%AC%E7%BE%8E%E9%A3%9F%E5%9C%B0%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>整理了下来北京后体验过的不错的馆子，方便自己查看，也顺便给他人指指路。</p><p>持续更新中…</p><h2 id="铜锅涮肉"><a href="#铜锅涮肉" class="headerlink" title="铜锅涮肉"></a>铜锅涮肉</h2><h3 id="聚宝源"><a href="#聚宝源" class="headerlink" title="聚宝源"></a>聚宝源</h3><p>这是一家连锁的清真餐厅。味道很地道，羊肉质量也不错。一般需要排队。</p><p>推荐指数：5星</p><h3 id="张记涮肉"><a href="#张记涮肉" class="headerlink" title="张记涮肉"></a>张记涮肉</h3><p>这家店在西城区的胡同里，是家老店，名气很大。老板很能聊，料碗自称是秘制的。一般需要排队。</p><p>推荐指数：4星</p><h3 id="阳坊胜利涮肉"><a href="#阳坊胜利涮肉" class="headerlink" title="阳坊胜利涮肉"></a>阳坊胜利涮肉</h3><p>这是一件连锁老店，起源是李胜利夫妇的涮肉店。消费接地气，经济实惠，不需要排队。</p><p>推荐指数：4星</p><h2 id="火锅"><a href="#火锅" class="headerlink" title="火锅"></a>火锅</h2><h3 id="黄门老灶"><a href="#黄门老灶" class="headerlink" title="黄门老灶"></a>黄门老灶</h3><p>连锁的重庆火锅店，上过《舌尖上的中国》，嗜辣者的福音。不需要排队。</p><p>推荐指数：4星</p><h2 id="北京菜"><a href="#北京菜" class="headerlink" title="北京菜"></a>北京菜</h2><h3 id="局气"><a href="#局气" class="headerlink" title="局气"></a>局气</h3><p>连锁的北京菜馆子，北京菜的种类全，味道正。一般需要排队。</p><p>推荐指数：5星</p><h2 id="东北菜"><a href="#东北菜" class="headerlink" title="东北菜"></a>东北菜</h2><h3 id="95号酱大骨"><a href="#95号酱大骨" class="headerlink" title="95号酱大骨"></a>95号酱大骨</h3><p>海淀区排名第一的东北菜馆子，招牌是酱大骨和锅包肉。一般需要排队。</p><p>推荐指数：5星</p><h3 id="人民公社"><a href="#人民公社" class="headerlink" title="人民公社"></a>人民公社</h3><p>连锁的东北菜馆子，菜量大，豪爽，装修充满革命气息，价格接地气。不需要排队。</p><p>推荐指数：4星</p><h2 id="湘菜"><a href="#湘菜" class="headerlink" title="湘菜"></a>湘菜</h2><h3 id="三湘鮰头鱼"><a href="#三湘鮰头鱼" class="headerlink" title="三湘鮰头鱼"></a>三湘鮰头鱼</h3><p>海淀区排名第一的湘菜馆子，招牌当然是鱼。馆子很小，位置隐蔽，爱湘菜的朋友可以试试，不需要排队。</p><p>推荐指数：5星</p><h2 id="烧烤"><a href="#烧烤" class="headerlink" title="烧烤"></a>烧烤</h2><h3 id="眼镜望京小腰"><a href="#眼镜望京小腰" class="headerlink" title="眼镜望京小腰"></a>眼镜望京小腰</h3><p>真正的望京小腰，他们家只有三家店，老店在南湖中园。他们家不提供外卖，外卖平台的上的望京小腰并不正宗。经常会有明星光顾。需要排队。</p><p>推荐指数：5星</p><h3 id="丰茂烤串"><a href="#丰茂烤串" class="headerlink" title="丰茂烤串"></a>丰茂烤串</h3><p>朝鲜风味的烧烤店，羊肉新鲜，味道好。一般需要排队。</p><p>推荐指数：5星</p><h2 id="羊羊羊"><a href="#羊羊羊" class="headerlink" title="羊羊羊"></a>羊羊羊</h2><h3 id="木辛水水冰煮羊"><a href="#木辛水水冰煮羊" class="headerlink" title="木辛水水冰煮羊"></a>木辛水水冰煮羊</h3><p>抖音和B站上很火的冰煮羊，吃法新鲜，羊肉嫩，不需要排队。</p><p>推荐指数：5星</p><h2 id="鱼鱼鱼"><a href="#鱼鱼鱼" class="headerlink" title="鱼鱼鱼"></a>鱼鱼鱼</h2><h3 id="旺顺阁鱼头泡饼"><a href="#旺顺阁鱼头泡饼" class="headerlink" title="旺顺阁鱼头泡饼"></a>旺顺阁鱼头泡饼</h3><p>连锁的鱼头泡饼店，鱼头大，精髓是泡饼，不需要排队。</p><p>推荐指数：5星</p><h2 id="烤鸭"><a href="#烤鸭" class="headerlink" title="烤鸭"></a>烤鸭</h2><h3 id="便宜坊"><a href="#便宜坊" class="headerlink" title="便宜坊"></a>便宜坊</h3><p>创始于明朝的北京烤鸭店，味道正宗，不需要排队。</p><p>推荐指数：5星</p><h3 id="大董烤鸭"><a href="#大董烤鸭" class="headerlink" title="大董烤鸭"></a>大董烤鸭</h3><p>定位高端，消费较高，但是味道正宗，不需要排队。</p><p>推荐指数：4星</p><h2 id="海鲜"><a href="#海鲜" class="headerlink" title="海鲜"></a>海鲜</h2><h3 id="胶东大盆海鲜"><a href="#胶东大盆海鲜" class="headerlink" title="胶东大盆海鲜"></a>胶东大盆海鲜</h3><p>位置在安定门附近一家小区里，螃蟹，皮皮虾，蛤蜊，鲅鱼水饺都有。菜量大，价格亲民。 不需要排队。</p><p>推荐指数：5星</p><h2 id="肉蟹煲"><a href="#肉蟹煲" class="headerlink" title="肉蟹煲"></a>肉蟹煲</h2><h3 id="胖哥俩"><a href="#胖哥俩" class="headerlink" title="胖哥俩"></a>胖哥俩</h3><p>招牌是蟹煲，里面的鸡爪超级入味好吃。不需要排队。</p><p>推荐指数：5星</p><h2 id="潮汕火锅"><a href="#潮汕火锅" class="headerlink" title="潮汕火锅"></a>潮汕火锅</h2><h3 id="牛麒荟"><a href="#牛麒荟" class="headerlink" title="牛麒荟"></a>牛麒荟</h3><p>他们家的牛肉质量特别好，手打牛肉丸也是特色，味道跟我在珠海吃的十分相似。</p><p>推荐指数：5星</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>【影评】我会在江湖等你</title>
      <link href="/2018/10/22/%E3%80%90%E5%BD%B1%E8%AF%84%E3%80%91%E6%88%91%E4%BC%9A%E5%9C%A8%E6%B1%9F%E6%B9%96%E7%AD%89%E4%BD%A0/"/>
      <url>/2018/10/22/%E3%80%90%E5%BD%B1%E8%AF%84%E3%80%91%E6%88%91%E4%BC%9A%E5%9C%A8%E6%B1%9F%E6%B9%96%E7%AD%89%E4%BD%A0/</url>
      
        <content type="html"><![CDATA[<p>《江湖儿女》的故事在一段段充满年代感的配乐中展开。</p><p>迪厅中的那段《YMCA》，随着节拍摇摆的巧巧和斌哥，春风得意。</p><p>皇冠车，雪茄烟，还有那首叶倩文的《浅醉一生》，让一切发生了转折。</p><p>五年的监狱生活足够让这个世界变得陌生。</p><p>不远万里南下寻找斌哥的巧巧得到的是冷冰冰的回应。</p><p>也许斌哥没那么爱巧巧，也许这个男人有更在乎的事情去做，人性总是难以捉摸，也禁不住捉摸。</p><p>恍惚间很多年过去了，巧巧也变成了小弟们口中的“巧姐”，而斌哥却坐上了轮椅，成了一个“废人”。</p><p>巧巧收留了斌哥，斌哥却在某天的清晨不辞而别。</p><p>多年以前，斌哥对巧巧说，“我们都是江湖上的人”。巧巧却否认道，“我不是江湖上的人”。</p><p>而现在，巧姐成了江湖中人，斌哥却远离了江湖。嗯，命运总是喜欢这样。</p><p>一世的悲喜交集，</p><p>我会在江湖等你。</p><p>一生的崖间浪里，</p><p>今生所爱的凭据。</p><p>半生的爱恨情欲，</p><p>我会在梦里等你。</p><p>安放在一座岛屿，</p><p>隔绝孤寂和欢喜。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>谈谈深拷贝与浅拷贝</title>
      <link href="/2018/10/19/%E8%B0%88%E8%B0%88%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2018/10/19/%E8%B0%88%E8%B0%88%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于深拷贝和浅拷贝其实是两个比较基础的概念，但是我还是想整理一下，因为里面有很多小细节还是很有意思的。</p><h2 id="深拷贝和浅拷贝的区别"><a href="#深拷贝和浅拷贝的区别" class="headerlink" title="深拷贝和浅拷贝的区别"></a>深拷贝和浅拷贝的区别</h2><p>深拷贝和浅拷贝是大家经常听到的两个名词，两者到底有什么不同呢？</p><p>先看看什么是浅拷贝。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br><span class="line">obj2.a = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">// &#123; a: 3, b: 2 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// &#123; a: 3, b: 2 &#125;</span></span><br></pre></td></tr></table></figure><p>这是一个最简单的浅拷贝的例子，我把obj1赋值给obj2，改变了obj2中的一个属性值，obj1中的相应属性值也跟着变化了，这是为什么呢？</p><p>因为<strong>浅拷贝其实只是引用的拷贝，两者还是指向内存中的同一个地址</strong>。简而言之，就是obj1和obj2其实指向的是同一个对象。打个比方，就像一个房间把门牌号1换成了门牌号2，但是这个房间还是这个房间。</p><p>那<strong>深拷贝就是两者指向不同的内存地址，是真正意义上的拷贝</strong>。拿上面的房间举例子，就是你真的重新开了一间房，并不是只是换门牌号。</p><h2 id="谈谈Object-assign"><a href="#谈谈Object-assign" class="headerlink" title="谈谈Object.assign()"></a>谈谈Object.assign()</h2><p>Object.assign()是我们经常用到的方法，其实这个方法就是浅拷贝。但是它又有一点特殊的地方，就是可以处理第一层的深拷贝。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1);</span><br><span class="line">obj2.a = <span class="number">3</span>;</span><br><span class="line">obj2.b.c = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">// &#123; a: 1, b: &#123; c: 3 &#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// &#123; a: 3, b: &#123; c: 3 &#125; &#125;</span></span><br></pre></td></tr></table></figure><p>看上面的例子，属性a的值并没有跟着变，但是属性b中的c的值跟着变了。</p><h2 id="常用的实现深拷贝的方式"><a href="#常用的实现深拷贝的方式" class="headerlink" title="常用的实现深拷贝的方式"></a>常用的实现深拷贝的方式</h2><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>这是最常用的实现深拷贝的方式，直接看例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj1));</span><br></pre></td></tr></table></figure><p>这种方法很简单而且好用，但是有一点点瑕疵，它会抛弃对象的constructor。也就是深拷贝之后，不管这个对象原来的构造函数是什么，在深拷贝之后都会变成Object。</p><p>而且这种方法能正确处理的对象只有 Number, String, Boolean, Array，即那些能够被JSON直接表示的数据结构。RegExp对象或者function是无法通过这种方式深拷贝。</p><h3 id="lodash"><a href="#lodash" class="headerlink" title="lodash"></a>lodash</h3><p>这是我个人目前使用的方法，只需要一行<code>var obj2 = _.cloneDeep(obj1)</code>就能实现。而且lodash是一个功能很强大的库，提供的方法可靠又简单，真的是懒人必备，<a href="https://www.lodashjs.com/" target="_blank" rel="noopener">点击这里</a>去了解它吧！</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>走进机器学习世界之TensorFlow.js快速上手</title>
      <link href="/2018/10/09/%E8%B5%B0%E8%BF%9B%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%96%E7%95%8C%E4%B9%8BTensorFlow.js%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
      <url>/2018/10/09/%E8%B5%B0%E8%BF%9B%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%96%E7%95%8C%E4%B9%8BTensorFlow.js%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近两年人工智能，机器学习等各种概念漫天飞舞，那么这些唬人的名词之间到底有什么区别和联系呢？</p><p>有句很有意思话：“怎样分辨<code>AI</code>和<code>Machine Learning</code>呢？用<code>Python</code>写的是<code>Machine Learning</code>，用<code>PowerPoint</code>写的是<code>AI</code>。”</p><p>还是言归正传，人工智能、机器学习和深度学习准确来说是层层包含的关系。如果用三个同心圆来解释的话，人工智能是最大的圆，机器学习是中间的圆，深度学习是最小的圆。具体解释如下：</p><ul><li>机器学习是实现人工智能的一种手段</li><li>深度学习是实现机器学习的一种技术</li></ul><p>今天我们要介绍的<code>TensorFlow.js</code>是由<code>Google</code>的<code>AI</code>团队发布一款机器学习框架，基于<code>DeepLearn.js</code>(已经停止更新)。这款机器学习框架的特点是使用<code>JavaScript</code>语言，在浏览器中就可以使用它提供的各种<code>API</code>来进行建模和训练，并且支持<code>Node.js</code>。所以对于前端来说，有什么理由不了解一下呢？</p><p>这里有一个利用<code>TensorFlow.js</code>实现的机器学习的小游戏，大家可以感受一下。<a href="https://storage.googleapis.com/tfjs-examples/webcam-transfer-learning/dist/index.html" target="_blank" rel="noopener">点我开始游戏！</a></p><p>这篇文章基于 <a href="https://js.tensorflow.org/#getting-started" target="_blank" rel="noopener">TensorFlow.js的英文官方文档</a> 写成，重点在于 TensorFlow.js 的入门，关于机器学习更多的知识点可参考 <a href="https://developers.google.cn/machine-learning/crash-course/" target="_blank" rel="noopener">Google机器学习课程</a>。</p><p>前言唠叨完了，让我们正式开始旅程吧！</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="直接引入"><a href="#直接引入" class="headerlink" title="直接引入"></a>直接引入</h3><p>第一种方式是直接引入，在浏览器中运行下面的代码，在控制台中可以看到结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;!-- Load TensorFlow.js --&gt;</span><br><span class="line">    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@0.13.0&quot;&gt; &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Place your code in the script tag below. You can also use an external .js file --&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      // Notice there is no &apos;import&apos; statement. &apos;tf&apos; is available on the index-page</span><br><span class="line">      // because of the script tag above.</span><br><span class="line"></span><br><span class="line">      // Define a model for linear regression.</span><br><span class="line">      const model = tf.sequential();</span><br><span class="line">      model.add(tf.layers.dense(&#123;units: 1, inputShape: [1]&#125;));</span><br><span class="line"></span><br><span class="line">      // Prepare the model for training: Specify the loss and the optimizer.</span><br><span class="line">model.compile(&#123;loss: &apos;meanSquaredError&apos;, optimizer: &apos;sgd&apos;&#125;);</span><br><span class="line"></span><br><span class="line">      // Generate some synthetic data for training.</span><br><span class="line">      const xs = tf.tensor2d([1, 2, 3, 4], [4, 1]);</span><br><span class="line">      const ys = tf.tensor2d([1, 3, 5, 7], [4, 1]);</span><br><span class="line"></span><br><span class="line">      // Train the model using the data.</span><br><span class="line">      model.fit(xs, ys, &#123;epochs: 10&#125;).then(() =&gt; &#123;</span><br><span class="line">        // Use the model to do inference on a data point the model hasn&apos;t seen before:</span><br><span class="line">        // Open the browser devtools to see the output</span><br><span class="line">        model.predict(tf.tensor2d([5], [1, 1])).print();</span><br><span class="line">      &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line"></span><br><span class="line">  &lt;body&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="npm-或-yarn"><a href="#npm-或-yarn" class="headerlink" title="npm 或 yarn"></a>npm 或 yarn</h3><p>第二种方式是通过<code>npm</code>或<code>yarn</code>将<code>TensorFlow.js</code>的库引入到你的项目中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn add @tensorflow/tfjs  </span><br><span class="line">npm install @tensorflow/tfjs</span><br></pre></td></tr></table></figure></p><p>你可以在你的main.js中添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import * as tf from &apos;@tensorflow/tfjs&apos;;</span><br><span class="line"></span><br><span class="line">// Define a model for linear regression.</span><br><span class="line">const model = tf.sequential();</span><br><span class="line">model.add(tf.layers.dense(&#123;units: 1, inputShape: [1]&#125;));</span><br><span class="line"></span><br><span class="line">// Prepare the model for training: Specify the loss and the optimizer.</span><br><span class="line">model.compile(&#123;loss: &apos;meanSquaredError&apos;, optimizer: &apos;sgd&apos;&#125;);</span><br><span class="line"></span><br><span class="line">// Generate some synthetic data for training.</span><br><span class="line">const xs = tf.tensor2d([1, 2, 3, 4], [4, 1]);</span><br><span class="line">const ys = tf.tensor2d([1, 3, 5, 7], [4, 1]);</span><br><span class="line"></span><br><span class="line">// Train the model using the data.</span><br><span class="line">model.fit(xs, ys, &#123;epochs: 10&#125;).then(() =&gt; &#123;</span><br><span class="line">  // Use the model to do inference on a data point the model hasn&apos;t seen before:</span><br><span class="line">  model.predict(tf.tensor2d([5], [1, 1])).print();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果不理解上面代码，请不要心急，继续看后面的一些基础概念和用法。</p><h2 id="Tensor-和-Variable"><a href="#Tensor-和-Variable" class="headerlink" title="Tensor 和 Variable"></a>Tensor 和 Variable</h2><p><code>Tensor</code>和<code>Variable</code>是<code>TensorFlow.js</code>中最基础的两种数据形式。那他们到底是什么意思呢？</p><p><code>Tensor</code>在谷歌翻译中是“张量”的意思，“张量”这个词是数学和物理中的一个术语，我们暂且不深究它的意思，你只需要记住，<code>Tensor</code>（张量）是不可变的，类似于<code>const</code>，一旦定义就不能改变它的值。</p><p><code>Variable</code>就很容易理解了，它是变量的意思，顾名思义，它的值是可以改变的。</p><p><strong>总之一句话，Tensor（张量）不可变，Variable（变量）可变。</strong></p><h3 id="Tensor"><a href="#Tensor" class="headerlink" title="Tensor"></a>Tensor</h3><p>张量通常是一个0到多维的数组，构造张量时会用到<code>shape</code>属性，用来规定这是一个几行几列的数组。<br>请看下面构造一个张量的例子。<code>shape</code>用来规定这个张量是两行三列的数组，然后可以看到最后的输出，我们得到了一个两行三列的二维数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shape = [<span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// 表示两行三列的矩阵</span></span><br><span class="line"><span class="keyword">const</span> a = tf.tensor([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">10.0</span>, <span class="number">20.0</span>, <span class="number">30.0</span>], shape);</span><br><span class="line">a.print(); <span class="comment">// 打印a的值</span></span><br><span class="line"><span class="comment">// 输出：[[1 , 2 , 3 ],</span></span><br><span class="line"><span class="comment">//      [10, 20, 30]]</span></span><br></pre></td></tr></table></figure><p>也可以用下面这种方式，直接表示这是一个两行三列的二维数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 也可以像下面这样创建一个两行三列的矩阵</span></span><br><span class="line"><span class="keyword">const</span> b = tf.tensor([[<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>], [<span class="number">10.0</span>, <span class="number">20.0</span>, <span class="number">30.0</span>]]);</span><br><span class="line">b.print();</span><br><span class="line"><span class="comment">// 输出: [[1 , 2 , 3 ],</span></span><br><span class="line"><span class="comment">//      [10, 20, 30]]</span></span><br></pre></td></tr></table></figure><p>然而实际上，我们通常使用<code>tf.scalar</code>, <code>tf.tensor1d</code>, <code>tf.tensor2d</code>, <code>tf.tensor3d</code>和<code>tf.tensor4d</code>来构造张量。<code>tf.scalar</code>是构造一个零维数组，也就是一个数字，<code>tf.tensor1d</code>是构造一位数组，<code>tf.tensor2d</code>是构造二维数组，以此类推。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> c = tf.tensor2d([[<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>], [<span class="number">10.0</span>, <span class="number">20.0</span>, <span class="number">30.0</span>]]);</span><br><span class="line">c.print();</span><br><span class="line"><span class="comment">// 输出: [[1 , 2 , 3 ],</span></span><br><span class="line"><span class="comment">//       [10, 20, 30]]</span></span><br></pre></td></tr></table></figure><p>或者使用<code>tf.zeros</code>生成全是0的数组，<code>tf.ones</code>生成全是1的数组，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个三行五列全是0的矩阵</span></span><br><span class="line"><span class="keyword">const</span> zeros = tf.zeros([<span class="number">3</span>, <span class="number">5</span>]);</span><br><span class="line"><span class="comment">// 输出: [[0, 0, 0, 0, 0],</span></span><br><span class="line"><span class="comment">//       [0, 0, 0, 0, 0],</span></span><br><span class="line"><span class="comment">//       [0, 0, 0, 0, 0]]</span></span><br></pre></td></tr></table></figure><h3 id="Variable"><a href="#Variable" class="headerlink" title="Variable"></a>Variable</h3><p>而<code>Variable</code>（变量）只能通过<code>Tensor</code>（张量）生成。我们可以使用<code>assign</code>给变量重新赋值。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialValues = tf.zeros([<span class="number">5</span>]);</span><br><span class="line"><span class="keyword">const</span> biases = tf.variable(initialValues);</span><br><span class="line">biases.print(); <span class="comment">// 输出: [0, 0, 0, 0, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> updatedValues = tf.tensor1d([<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]);</span><br><span class="line">biases.assign(updatedValues); <span class="comment">// 重新赋值</span></span><br><span class="line">biases.print(); <span class="comment">// 输出: [0, 1, 0, 1, 0]</span></span><br></pre></td></tr></table></figure><h2 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h2><p><code>TensorFlow.js</code>提供了各种向量运算的<code>API</code>，我们可以称这些为<code>Operations</code>。下面是张量平方和张量相加的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> d = tf.tensor2d([[<span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>]]);</span><br><span class="line"><span class="keyword">const</span> d_squared = d.square();</span><br><span class="line">d_squared.print();</span><br><span class="line"><span class="comment">// 输出: [[1, 4 ],</span></span><br><span class="line"><span class="comment">//       [9, 16]]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> e = tf.tensor2d([[<span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>]]);</span><br><span class="line"><span class="keyword">const</span> f = tf.tensor2d([[<span class="number">5.0</span>, <span class="number">6.0</span>], [<span class="number">7.0</span>, <span class="number">8.0</span>]]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> e_plus_f = e.add(f);</span><br><span class="line">e_plus_f.print();</span><br><span class="line"><span class="comment">// 输出: [[6 , 8 ],</span></span><br><span class="line"><span class="comment">//       [10, 12]]</span></span><br></pre></td></tr></table></figure><p>而且<code>TensorFlow.js</code>还提供了链式运算，请看例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sq_sum = e.add(f).square();</span><br><span class="line">sq_sum.print();</span><br><span class="line"><span class="comment">// 输出: [[36 , 64 ],</span></span><br><span class="line"><span class="comment">//       [100, 144]]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 你也可以这样做：</span></span><br><span class="line"><span class="keyword">const</span> sq_sum = tf.square(tf.add(e, f));</span><br></pre></td></tr></table></figure><h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><p>上面我们介绍了张量，变量和一些基础运算，下面我们引入<code>Model</code>（模型）这个概念。</p><p>模型就是一个函数，给定这个函数特定的输入，会返回特定的输出。</p><p><strong>所以请记住，模型就是一个函数而已。</strong></p><p>我们来看一个定义模型的例子, 以下代码构造了一个<code>y = a * x ^ 2 + b * x + c</code>的函数表达式，给定一个<code>x</code>，我们会得到一个 <code>y</code>。</p><p>代码中<code>tf.tidy()</code>看不懂请忽略，我们将在下一节介绍，它只是用来清除内存。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">predict</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// y = a * x ^ 2 + b * x + c</span></span><br><span class="line">  <span class="keyword">return</span> tf.tidy(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> x = tf.scalar(input);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> ax2 = a.mul(x.square());</span><br><span class="line">    <span class="keyword">const</span> bx = b.mul(x);</span><br><span class="line">    <span class="keyword">const</span> y = ax2.add(bx).add(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// y = 2x^2 + 4x + 8</span></span><br><span class="line"><span class="keyword">const</span> a = tf.scalar(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> b = tf.scalar(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">const</span> c = tf.scalar(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当输入是 2 时得到结果</span></span><br><span class="line"><span class="keyword">const</span> result = predict(<span class="number">2</span>);</span><br><span class="line">result.print() <span class="comment">// 输出: 24</span></span><br></pre></td></tr></table></figure><p>但是通常，我们会使用一个更高级的<code>API</code>去构造模型，那就是用<code>tf.model</code>的形式，这里的<code>model</code>只是模型的总称，并没有 <code>tf.modal</code>这个方法。<code>TensorFlow</code>中最常用的是<code>tf.sequential</code>，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> model = tf.sequential();</span><br><span class="line">model.add(</span><br><span class="line">  tf.layers.simpleRNN(&#123;</span><br><span class="line">    units: <span class="number">20</span>,</span><br><span class="line">    recurrentInitializer: <span class="string">'GlorotNormal'</span>,</span><br><span class="line">    inputShape: [<span class="number">80</span>, <span class="number">4</span>]</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> optimizer = tf.train.sgd(LEARNING_RATE);</span><br><span class="line">model.compile(&#123;optimizer, <span class="attr">loss</span>: <span class="string">'categoricalCrossentropy'</span>&#125;);</span><br><span class="line">model.fit(&#123;<span class="attr">x</span>: data, <span class="attr">y</span>: labels&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中一定有很多你不理解的地方，比如什么是<code>tf.layer</code>？什么是<code>tf.train.sgd</code>？这里可以先忽略细节，先从总体上体会这些基本概念，关于<code>tf.train.sg</code>等我们在后面的文章介绍。如果你忍不住，在这里可以查到<a href="https://js.tensorflow.org/api/0.13.0/#Tensors-Transformations" target="_blank" rel="noopener">官方API文档</a>！</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p><code>TensorFlow.js</code>使用<code>GPU</code>来加速运算，所以合理地释放内存是一件很必要的事情。<code>TensorFlow.js</code>提供了<code>dispose</code>函数来释放内存，请看例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = tf.tensor2d([[<span class="number">0.0</span>, <span class="number">2.0</span>], [<span class="number">4.0</span>, <span class="number">6.0</span>]]);</span><br><span class="line"><span class="keyword">const</span> x_squared = x.square();</span><br><span class="line"></span><br><span class="line">x.dispose();</span><br><span class="line">x_squared.dispose();</span><br></pre></td></tr></table></figure><p>但是通常实际中我们会面对很多的张量和操作，这时候<code>tf.tidy</code>更加方便，因为它是批量释放内存，请看例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给 ty.tidy 传入一个函数，这个函数会被清理。把计算函数放在 ty.tidy 中是官方推荐的做法。</span></span><br><span class="line"><span class="keyword">const</span> average = tf.tidy(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> y = tf.tensor1d([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>]);</span><br><span class="line">  <span class="keyword">const</span> z = tf.ones([<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> y.sub(z).square().mean();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">average.print() <span class="comment">// Output: 3.5</span></span><br></pre></td></tr></table></figure><p>使用<code>tf.tidy</code>有两个要点：</p><ul><li>传递给<code>tf.tidy</code>的函数必须是同步的。</li><li><code>tf.tidy</code>不会清理变量，你只能通过<code>dispose</code>手动清理。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于<code>TensorFlow.js</code>的基础概念介绍完了，但是<code>TensorFlow.js</code>只是我们探索机器学习的一个工具而已，具体的实践还需要更多的学习，后面我也会跟大家一起学习，并及时分享。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>【随笔】夏天的风</title>
      <link href="/2018/10/08/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%91%E5%A4%8F%E5%A4%A9%E7%9A%84%E9%A3%8E/"/>
      <url>/2018/10/08/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%91%E5%A4%8F%E5%A4%A9%E7%9A%84%E9%A3%8E/</url>
      
        <content type="html"><![CDATA[<p>突然发现已经秋天了，才意识到回国已经五个月了。</p><p>习惯了欧洲宁静的街道，刚到北京的时候，朋友请吃饭，过马路的时候我有点手足无措，朋友大笑不止。</p><p>到现在，开着车穿梭在二三四五环，偶尔会咒骂一下肆意横行的电动车。</p><p>我似乎已经融入了北京的生活。</p><p>从采购平台，SaaS多门店，再到SaaS 3.0优化需求，参与了几个大大小小的项目，技术上熟练了不少，但还是有待精进。</p><p>认识了些有趣的人，看了些有趣的展，喝了些不同口味的酒。</p><p>从五道口的小酒馆到阿那亚的海滩，从珠海的深夜路边摊到澳门的街头，去了些地方，有开心也有难过。</p><p>“夏天的风，正暖暖吹过，穿过头发，穿过耳朵。”</p><p>多希望北京的夏天能久一点。</p><p>已经秋天了，还有些事情没有做，还有些梦想没实现。</p><p>未来，还要加油。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>【随笔】马孔多在下雨</title>
      <link href="/2018/10/08/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%91%E9%A9%AC%E5%AD%94%E5%A4%9A%E5%9C%A8%E4%B8%8B%E9%9B%A8/"/>
      <url>/2018/10/08/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%91%E9%A9%AC%E5%AD%94%E5%A4%9A%E5%9C%A8%E4%B8%8B%E9%9B%A8/</url>
      
        <content type="html"><![CDATA[<p>近日又翻起了《百年孤独》这本书，上一次读还是18年的3月份。</p><p>那时候我坐在从巴黎到第戎的火车上，窗外刚好是春天。</p><p>喜欢马尔克斯和他的魔幻现实主义。</p><p>印象最深的是奥雷里亚诺上校和儿时好友赫里内勒多的对话：</p><blockquote><p>“奥雷里亚诺，”他悲伤地敲下发报键，“马孔多在下雨。”<br>线路上一阵长久的沉默。忽然，机器上跳出奥雷里亚诺上校冷漠的电码。<br>“别犯傻了，赫里内勒多，”电码如是说道，“八月下雨很正常。”</p></blockquote><p>“马孔多在下雨。” 这是赫里内勒多最后的一句矫情。</p><p>“家里下雨了。” 在欧洲的两年，偶尔会听到电话那头母亲的声音。</p><p>是啊，家里下雨了。</p><p>“而今识尽愁滋味，欲说还休，欲说还休，却道天凉好个秋。”</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>快速了解React的组件生命周期</title>
      <link href="/2018/10/08/%E5%BF%AB%E9%80%9F%E4%BA%86%E8%A7%A3React%E7%9A%84%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2018/10/08/%E5%BF%AB%E9%80%9F%E4%BA%86%E8%A7%A3React%E7%9A%84%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>工作快要满两个月了，一直在使用React全家桶（React + React Redux + Router + Ant Design）。工作中涉及到React生命周期函数的使用非常多，在此做一个整理。</p><h2 id="React的组件生命周期"><a href="#React的组件生命周期" class="headerlink" title="React的组件生命周期"></a>React的组件生命周期</h2><p>在这里我想引用 <a href="http://www.css88.com/react/docs/react-component.html" target="_blank" rel="noopener">React中文文档</a> 中的原话：</p><blockquote><p>每个组件都有几个 “生命周期方法” ，您可以重写这些方法，以在过程中的特定时间运行代码。 前缀为 will 的方法在一些事情发生之前被调用，而前缀为 did 的方法在一些事情发生后被调用。</p></blockquote><p>这段话告诉我们三件事情：</p><ol><li>生命周期方法我们可以自己改写。</li><li>前缀是 will 的方法在一些事情发生之前被调用。</li><li>前缀为 did 的方法在一些事情发生后被调用。</li></ol><p>那组件的生命周期分为哪几个过程呢？共有三大过程：<strong>Mounting(装载)，Updating(更新)，Unmounting(卸载)</strong></p><p><strong>Mounting</strong>的意思就是一个组件实例被创建并将其插入 DOM 中；</p><p><strong>Updating</strong>的意思就是刚刚完成Mounting的这个组件实例发生了变化，比如改变了 props 或 state；</p><p><strong>Unmounting</strong>的意思就是这个组件从 DOM 中删除；</p><p>简而言之就是这三大过程，我去首次挂载这个组件，我去更新这个组件，我去卸载这个组件。<br>以下要介绍的组件的生命周期函数全都是围绕这三大过程。</p><h2 id="组件的生命周期函数"><a href="#组件的生命周期函数" class="headerlink" title="组件的生命周期函数"></a>组件的生命周期函数</h2><h3 id="当Mounting发生的时候"><a href="#当Mounting发生的时候" class="headerlink" title="当Mounting发生的时候"></a>当Mounting发生的时候</h3><p>当组件挂载发生的时候，以下函数先后触发：</p><ol><li>constructor()</li><li>componentWillMount()</li><li>render()</li><li>componentDidMount()</li></ol><h3 id="当Updating发生的时候"><a href="#当Updating发生的时候" class="headerlink" title="当Updating发生的时候"></a>当Updating发生的时候</h3><p>当组件更新发生的时候，以下函数先后触发：</p><ol><li>componentWillReceiveProps()</li><li>shouldComponentUpdate()</li><li>componentWillUpdate()</li><li>render()</li><li>componentDidUpdate()</li></ol><h3 id="当Unmounting发生的时候"><a href="#当Unmounting发生的时候" class="headerlink" title="当Unmounting发生的时候"></a>当Unmounting发生的时候</h3><p>当组件卸载发生的时候，这个函数触发：</p><ul><li>componentWillUnmount()</li></ul><p>具体的函数参数和使用可以参考 <a href="http://www.css88.com/react/docs/react-component.html#constructor" target="_blank" rel="noopener">React生命周期函数</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这些函数还是很有用的。</p><p>比如，在一个组件里要做一些后端数据请求，我们都是把请求放在<code>componentDidMount()</code>中；自定义Form组件的时候，我们经常会用到<code>componentWillReceiveProps()</code>。</p><p>当然这些是我个人的一些经验，就不展开说了。大家遇到类似需求的时候，别忘了这些好用的函数就好了。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>之后在读《深入React技术栈》这本书的时候，发现了一个描述React生命周期的很清晰的图，在这里贴一下：</p><p><img src="https://ws1.sinaimg.cn/large/0072eorIgy1fw0thfko2fj30m80ec3zq.jpg" alt="clipboard.png"></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>个人最顺手的git工作流程</title>
      <link href="/2018/10/08/%E4%B8%AA%E4%BA%BA%E6%9C%80%E9%A1%BA%E6%89%8B%E7%9A%84git%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/"/>
      <url>/2018/10/08/%E4%B8%AA%E4%BA%BA%E6%9C%80%E9%A1%BA%E6%89%8B%E7%9A%84git%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>入职满一个月了，目前我们组是使用gitlab合作开发，在这里总结了一下git的使用流程。这一套流程是我目前自己在用的，感觉还不错。</p><h3 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone + URL //创建本地仓库</span><br><span class="line">git checkout origin/dev -b dev //拉取远程dev分支到本地dev分支</span><br><span class="line">git checkout -b ningliu //新建自己的本地分支ningliu（ningliu是我的名字）</span><br><span class="line">git push --set-upstream origin ningliu //把自己的本地分支同步到远端分支</span><br><span class="line">git checkout ningliu //确保在自己的本地分支操作</span><br></pre></td></tr></table></figure></code></pre><h3 id="每次修改完代码"><a href="#每次修改完代码" class="headerlink" title="每次修改完代码"></a>每次修改完代码</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add . //把自己的修改推送到本地index区</span><br><span class="line">git commit -m &quot;这里写提交的信息哦&quot; //把自己的修改推送到head区，并附加提交信息</span><br></pre></td></tr></table></figure></code></pre><p>备注：不理解index区和head区等基本概念的推荐阅读 [git - 简易指南][1]。 这篇文章足够了解基本概念了。</p><h3 id="重头戏：更新到远端仓库"><a href="#重头戏：更新到远端仓库" class="headerlink" title="重头戏：更新到远端仓库"></a>重头戏：更新到远端仓库</h3><p>我是将以下代码保存成<code>git.sh</code>文件，放在项目根目录下，每次运行<code>sh git.sh</code>即可自动实现以下命令。</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">if [ $? -ne 0 ]; then</span><br><span class="line">exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">MAIN=&quot;dev&quot;</span><br><span class="line"># 将变量 ME 的值改为自己的分支名</span><br><span class="line">ME=&quot;branch_name&quot;</span><br><span class="line"></span><br><span class="line">git push # 把本地自己分支的修改推送到远端自己分支</span><br><span class="line">git pull # 拉取远端自己分支的更新</span><br><span class="line">git merge origin/$&#123;MAIN&#125; # 把远端dev分支合并到本地自己分支</span><br><span class="line">git push # 把本地自己分支的修改推送到远端自己分支</span><br><span class="line"></span><br><span class="line">git checkout $&#123;MAIN&#125; # 切换到本地dev分支</span><br><span class="line">git pull # 拉取远端dev分支的更新</span><br><span class="line">git merge $&#123;ME&#125; # 把本地自己分支合并到本地dev分支</span><br><span class="line">git push # 把本地dev分支的修改推送到远端dev分支</span><br><span class="line"></span><br><span class="line">git checkout $&#123;ME&#125; # 切换回自己的本地分支</span><br></pre></td></tr></table></figure></code></pre><p>每行命令我已经加上了注释。总之这几行命令实现了本地和远端自己的分支、本地和远端的dev分支的同步。前四行是实现自己分支的最新化，后四行是实现dev分支的最新化。</p><p>如果同步过程中遇到冲突，再自行解决。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这是我目前最顺手的git工作流程，如果有更好的实践，欢迎大家一起讨论。</p><h3 id="补充场景"><a href="#补充场景" class="headerlink" title="补充场景"></a>补充场景</h3><p>根据工作中遇到的场景越来越多，特此做一下补充：</p><h4 id="场景一：上线前需要合并master分支"><a href="#场景一：上线前需要合并master分支" class="headerlink" title="场景一：上线前需要合并master分支"></a>场景一：上线前需要合并master分支</h4><p>每次上线都要合并master，为了保证代码的新鲜度，这个时候可以用以下命令合并master分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch #下载一下远程代码</span><br><span class="line">git merge orgin/master #把master分支合并到当前分支</span><br></pre></td></tr></table></figure><h4 id="场景二：修改线上BUG"><a href="#场景二：修改线上BUG" class="headerlink" title="场景二：修改线上BUG"></a>场景二：修改线上BUG</h4><p>先在gitlab上基于master新建一个新的修改bug分支，例如master_fix<br>然后使用以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master:master_fix #拉取远程分支到本地</span><br></pre></td></tr></table></figure><p>需要修改的内容在这个分支修改就可以了。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>几张图看明白MVC MVP MVVM</title>
      <link href="/2018/10/08/%E5%87%A0%E5%BC%A0%E5%9B%BE%E7%9C%8B%E6%98%8E%E7%99%BDMVC%20MVP%20MVVM/"/>
      <url>/2018/10/08/%E5%87%A0%E5%BC%A0%E5%9B%BE%E7%9C%8B%E6%98%8E%E7%99%BDMVC%20MVP%20MVVM/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章整理于阮一峰老师的文章，我整理过来做一下学习记录，也方便有需要的朋友浏览。</p><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC由以下三部分组成：</p><p><img src="https://ws1.sinaimg.cn/large/0072eorIgy1fw0smeix2ej30e809rmx0.jpg" alt="图片描述"></p><ol><li><strong>视图（View）：</strong>用户界面</li><li><strong>控制器（Controller）：</strong>业务逻辑</li><li><strong>模型（Model）：</strong>数据保存</li></ol><p>各部分之间的通信过程如下：</p><p><img src="https://ws1.sinaimg.cn/large/0072eorIgy1fw0sme84axj30g009qglq.jpg" alt="图片描述"></p><ol><li>View 传送指令到 Controller</li><li>Controller 完成业务逻辑后，要求 Model 改变状态</li><li>Model 将新的数据发送到 View，用户得到反馈</li></ol><p>用户进行操作时，MVC可以分成两种方式。一种是通过 View 接受指令，传递给 Controller：</p><p><img src="https://ws1.sinaimg.cn/large/0072eorIgy1fw0smdbphhj30g00e0mxm.jpg" alt="图片描述"></p><p>另一种是直接通过controller接受指令：</p><p><img src="https://ws1.sinaimg.cn/large/0072eorIgy1fw0smd4vpij30fm0di74h.jpg" alt="图片描述"></p><h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p>MVP 模式将 Controller 改名为 Presenter，同时改变了通信方向：</p><p><img src="https://ws1.sinaimg.cn/large/0072eorIgy1fw0smcz7eqj30ex08zjrb.jpg" alt="图片描述"></p><ol><li>各部分之间的通信，都是双向的</li><li>View 与 Model 不发生联系，都通过 Presenter 传递</li><li>View 非常薄，不部署任何业务逻辑，称为被动视图（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里</li></ol><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致，唯一的区别是，它采用<strong>双向绑定</strong>（data-binding），View的变动，自动反映在 ViewModel，反之亦然：</p><p><img src="https://ws1.sinaimg.cn/large/0072eorIgy1fw0smcsd8wj30fg0brwef.jpg" alt="图片描述"></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Vue底层实现原理概述</title>
      <link href="/2018/10/08/Vue%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/"/>
      <url>/2018/10/08/Vue%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在研究 <a href="https://segmentfault.com/a/1190000006599500" target="_blank" rel="noopener">剖析Vue原理&amp;实现双向绑定MVVM</a> 这篇文章，一边学习一边总结一下自己的思考。</p><p>Vue是一个典型的MVVM框架，模型（Model）只是普通的JavaScript对象，修改它则视图（View）会自动更新。这种设计让状态管理变得非常简单而直观。那么Vue是如何把模型和视图建立起关联的呢？</p><h2 id="实现原理概述"><a href="#实现原理概述" class="headerlink" title="实现原理概述"></a>实现原理概述</h2><p>这是前言提到的文章里的代码，一段典型的体现了Vue特点的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"mvvm-app"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> v-model=<span class="string">"word"</span>&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;word&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button v-on:click="sayHi"&gt;change model&lt;/</span>button&gt; <span class="comment">//点击这个button，word的值会发生改变</span></span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script src="./</span>js/observer.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;script src="</span>./js/watcher.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;script src="</span>./js/compile.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;script src="</span>./js/mvvm.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">    var vm = new MVVM(&#123;</span></span><br><span class="line"><span class="string">        el: '#mvvm-app',</span></span><br><span class="line"><span class="string">        data: &#123;</span></span><br><span class="line"><span class="string">            word: 'Hello World!'</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        methods: &#123;</span></span><br><span class="line"><span class="string">            sayHi: function() &#123;</span></span><br><span class="line"><span class="string">                this.word = 'Hi, everybody!';</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>Vue实现这种数据双向绑定的效果，需要三大模块：</p><ol><li><p><strong>Observer</strong>：能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者</p></li><li><p><strong>Compile</strong>：对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数</p></li><li><p><strong>Watcher</strong>：作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图</p></li></ol><h2 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h2><p>Observer的核心是通过<code>Obeject.defineProperty()</code>来监听数据的变动，这个函数内部可以定义<code>setter</code>和<code>getter</code>，每当数据发生变化，就会触发<code>setter</code>。这时候<code>Observer</code>就要通知订阅者，订阅者就是<code>Watcher</code>。</p><h2 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h2><p><code>Watcher</code>订阅者作为<code>Observer</code>和<code>Compile</code>之间通信的桥梁，主要做的事情是：</p><ol><li>在自身实例化时往属性订阅器(dep)里面添加自己</li><li>自身必须有一个<code>update()</code>方法</li><li>待属性变动<code>dep.notice()</code>通知时，能调用自身的update()方法，并触发<code>Compile</code>中绑定的回调</li></ol><h2 id="Compile"><a href="#Compile" class="headerlink" title="Compile"></a>Compile</h2><p><code>Compile</code>主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于每部分具体的代码实现，可以参阅 <a href="https://segmentfault.com/a/1190000006599500" target="_blank" rel="noopener">剖析Vue原理&amp;实现双向绑定MVVM</a> 这篇文章，这篇文章写得非常好。我打算研究透彻之后自己实现一下简易的Vue框架。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>如果你还搞不懂HTTP报文</title>
      <link href="/2018/10/08/%E5%A6%82%E6%9E%9C%E4%BD%A0%E8%BF%98%E6%90%9E%E4%B8%8D%E6%87%82HTTP%E6%8A%A5%E6%96%87/"/>
      <url>/2018/10/08/%E5%A6%82%E6%9E%9C%E4%BD%A0%E8%BF%98%E6%90%9E%E4%B8%8D%E6%87%82HTTP%E6%8A%A5%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>HTTP报文由三部分组成：</p><ol><li><strong>起始行</strong>：报文的第一行就是起始行,在请求报文中用来说明要做些什么,在响应报文中说明出现了什么情况</li><li><strong>报文头</strong>：起始行后面有零个或多个字段。每个字段都包含一个名字和一个值,为了便于解析,两者之间用冒号(:)来分隔，<strong>首部以一个空行结束</strong>。</li><li><strong>主体</strong>：空行之后就是可选的报文主体了，其中包含了所有类型的数据。请求主体是要发送给服务器的数据;响应主体是要返回给客户端的数据。起始行和报文都是文本且都是结构化的,而主体则不同,主体中可以包含任意的二进制数据(比如图片、视频)。当然,主体中也可以包含文本。</li></ol><h2 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h2><p>一个请求报文<strong>起始行</strong>的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /dir/index.html HTTP/1.1</span><br></pre></td></tr></table></figure><ul><li>GET：这里指明请求方法是GET，还有其它方法比如POST、DELETE、HEAD、OPTIONS、PUT、TRACE</li><li>/dir/index.html：这里指明URL，它和报文头的Host属性组成完整的请求URL</li><li>HTTP/1.1：这里指明协议名称及版本号</li></ul><p><strong>报文头</strong>里有很多的字段，具几个常见的例子：</p><ul><li><code>Host</code>：请求的服务器地址，比如<a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a></li><li><code>Accept</code>: 指明客户端可以接受的数据类型，比如text/html</li><li><code>Cookie</code>：携带的Cookie信息</li><li><code>Cache-Control</code>：对缓存进行控制，指明一个请求希望响应返回的内容在客户端要被缓存多久或是否缓存</li></ul><p>还有非常多的字段，可以查阅文档，例如 [HTTP MDN][1]</p><p>最后举一个<strong>请求主体</strong>的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=ning&amp;age=24</span><br></pre></td></tr></table></figure><p>这里的请求主体就是我们提交的表单里的数据。</p><h2 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h2><p>一个响应报文<strong>起始行</strong>的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure><p>跟请求报文比，响应报文的起始行里多了一个状态码来告诉客户端本次请求的处理结果。以下是状态码的类型：</p><p><img src="https://ws1.sinaimg.cn/large/0072eorIgy1fw0t0vqqghj30ko072glr.jpg" alt="状态码类型"></p><p>例如：</p><p>200 OK </p><p>303 See Other </p><p>304 Not Modified </p><p>404 Not Found </p><p>500 Internal Server Error </p><p>关于响应报文头里面的各种字段，可以查阅文档 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP" target="_blank" rel="noopener">HTTP MDN</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这些就是关于HTTP报文的基本知识点，其实内容最多地方是报文头里各种字段的用法，比如很多字段是用来做浏览器缓存控制的。因为涉及字段的内容太多了，更具体的字段用法可以查阅文档 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP" target="_blank" rel="noopener">HTTP MDN</a>。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>跨域问题的根本解决方案CORS</title>
      <link href="/2018/10/08/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B9%E6%9C%AC%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88CORS/"/>
      <url>/2018/10/08/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B9%E6%9C%AC%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88CORS/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>关于跨域问题有很多的解决方案，这里我们总结一下目前最通用最强大的解决方案：CORS。</p><p>W3C 的 Web 工作组推荐了一种新的机制，即跨域资源共享（Cross-origin Resource Sharing），简称CORS。其实这个机制就是实现了跨站访问控制，使得安全地进行跨站数据传输成为可能。</p><p>跨源资源共享标准( cross-origin sharing standard) 使得以下场景可以使用跨站 HTTP 请求：</p><ol><li>使用 XMLHttpRequest 或 Fetch发起跨站 HTTP 请求。</li><li>Web 字体 (CSS 中通过 @font-face 使用跨站字体资源)，因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用。</li><li>WebGL 贴图</li><li>使用drawImage绘制</li><li>Images/video 画面到canvas.</li><li>样式表（使用 CSSOM）</li><li>Scripts (for unmuted exceptions)</li></ol><p>CORS分为<strong>简单请求</strong>和<strong>复杂请求</strong>，处理方法也是有不同的，所以我们分别总结。</p><h1 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h1><p>什么是简单请求呢？同时满足以下两个条件，就是简单请求：</p><ol><li>请求是下列之一：<br><code>HEAD</code><br><code>GET</code><br><code>POST</code></li><li>HTTP的头信息不超出以下几种字段：<br><code>Accept</code><br><code>Accept-Language</code><br><code>Content-Language</code><br><code>Last-Event-ID</code><br><code>Content-Type</code>：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</li></ol><p>实现方法非常简单，只需要把服务器的响应报文里的<code>Access-Control-Allow-Origin</code>设置为<code>*</code>或者包含由 <code>Origin</code>指明的站点。</p><p><code>Access-Control-Allow-Origin</code>是<strong>HTTP响应报文</strong>中的一个字段，<code>Origin</code>是<strong>HTTP请求报文</strong>中的以一个字段,如果不清楚这两个字段的话，可以自行查阅关于<strong>HTTP报文</strong>的知识，比如<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP" target="_blank" rel="noopener">HTTP | MDN</a>。</p><h1 id="复杂请求"><a href="#复杂请求" class="headerlink" title="复杂请求"></a>复杂请求</h1><p>如果不是简单请求，那就是复杂请求，比如请求的方法是<code>PUT</code>或者<code>DELETE</code>，比如<code>Content-Type</code>字段的类型是application/json，比如设置了自定义头信息。</p><p>复杂请求就是比简单请求多了个预检请求（preflight）而已。</p><p>预检请求就是浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。</p><p>预检请求用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字段是<code>Origin</code>，表示请求来自哪个源。除了<code>Origin</code>字段，还有两个字段非常重要：<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>，分别表示允许的请求方法和请求头。</p><p>举一个具体的例子：</p><p>现在，我们有一个页面向服务器发送了一个<code>POST</code>请求，并且我们自己定义了一个请求头字段<code>My-HEADER</code>，这时候浏览器就会首先发送一个<code>OPTION</code>请求来做预检请求，请求头里有以下字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Request-Method: POST</span><br><span class="line">Access-Control-Request-Headers: My-HEADER</span><br></pre></td></tr></table></figure><p>如果预检请求成功的话，响应头里的内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://example.com //表明服务器允许http://example.com的请求</span><br><span class="line">Access-Control-Allow-Methods: POST, GET, OPTIONS //表明服务器可以接受POST, GET和 OPTIONS的请求方法</span><br><span class="line">Access-Control-Allow-Headers: My-HEADER //传递一个可接受的自定义请求头列表</span><br><span class="line">Access-Control-Max-Age: 3000000 //告诉浏览器，本次预检请求的响应结果有效时间是多久</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是CORS方法解决跨域问题的流程，CORS支持所有类型的HTTP请求，是目前跨域问题的根本解决方案。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>什么是跨域以及几种简单解决方案</title>
      <link href="/2018/10/08/%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%E4%BB%A5%E5%8F%8A%E5%87%A0%E7%A7%8D%E7%AE%80%E5%8D%95%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2018/10/08/%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%E4%BB%A5%E5%8F%8A%E5%87%A0%E7%A7%8D%E7%AE%80%E5%8D%95%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a>什么是跨域？</h1><p>要明白什么是跨域之前，首先要明白什么是<strong>同源策略</strong>？</p><p>同源策略就是用来限制从一个源加载的文档或脚本与来自另一个源的资源进行交互。那怎样判断是否是同源呢？</p><p>如果协议，端口（如果指定了）和主机对于两个页面是相同的，则两个页面具有相同的源，也就是同源。也就是说，要同时满足以下3个条件，才能叫同源：</p><ol><li>协议相同</li><li>端口相同</li><li>主机相同</li></ol><p>举个例子就一目了然了：</p><p>我们来看下面的页面是否与 <code>http://store.company.com/dir/index.html</code> 是同源的？</p><ol><li><code>http://store.company.com/dir/index2.html</code>   同源 </li><li><code>http://store.company.com/dir2/index3.html</code>  同源 虽然在不同文件夹下</li><li><code>https://store.company.com/secure.html</code>     不同源 不同的协议(https) </li><li><code>http://store.company.com:81/dir/index.html</code> 不同源 不同的端口(81) </li><li><code>http://news.company.com/dir/other.html</code>     不同源 不同的主机(news)</li></ol><p>所以当面对跨域问题的时候，有什么解决方案呢？</p><h1 id="跨域的几种解决方案"><a href="#跨域的几种解决方案" class="headerlink" title="跨域的几种解决方案"></a>跨域的几种解决方案</h1><h2 id="document-domain方法"><a href="#document-domain方法" class="headerlink" title="document.domain方法"></a>document.domain方法</h2><p>我们来看一个具体场景：有一个页面 <code>http://www.example.com/a.html</code> ，它里面有一个<code>iframe</code>，这个<code>iframe</code>的源是 <code>http://example.com/b.html</code> ，很显然它们是不同源的，所以我们无法在父页面中操控子页面的内容。</p><p>解决方案如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- b.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.domain = <span class="string">'example.com'</span>;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- a.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.domain = <span class="string">'example.com'</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>).contentWindow.document;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="comment">//后面就可以操作iframe里的内容了...</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以我们只要将两个页面的document.domain设置成一致就可以了，要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域。</p><p>但是，这种方法只能解决主域相同的跨域问题。</p><h2 id="window-name方法"><a href="#window-name方法" class="headerlink" title="window.name方法"></a>window.name方法</h2><p>window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。</p><p>我们来看一个具体场景，在一个页面 <code>example.com/a.html</code> 中，我们想获取 <code>data.com/data.html</code> 中的数据，以下是解决方案：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- data.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.name = <span class="string">'data'</span>; <span class="comment">//这是就是我们需要通信的数据</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- a.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">getData</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</span></span><br><span class="line"><span class="javascript">        iframe.src = <span class="string">'example.com/b.html'</span>; <span class="comment">// 这里让iframe与父页面同源</span></span></span><br><span class="line"><span class="undefined">        </span></span><br><span class="line"><span class="javascript">        iframe.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> data = iframe.contentWindow.name; <span class="comment">//在这里我们得到了跨域页面中传来的数据</span></span></span><br><span class="line"><span class="undefined">        &#125;;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="JSONP方法"><a href="#JSONP方法" class="headerlink" title="JSONP方法"></a>JSONP方法</h2><p>JONSP(JSON with Padding)是JSON的一种使用模式。基本原理如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- a.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">dealData</span> (<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(data);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'http://example.com/data.php?callback=dealData'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $callback = $_GET[<span class="string">'callback'</span>];</span><br><span class="line">    $data = <span class="string">'data'</span>;</span><br><span class="line">    <span class="keyword">echo</span> $callback.<span class="string">'('</span>.json_encode($data).<span class="string">')'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>这时候在<code>a.html</code>中我们得到了一条js的执行语句<code>dealData(&#39;data&#39;)</code>，从而达到了跨域的目的。</p><p>所以JSONP的原理其实就是利用引入<code>script</code>不限制源的特点，把处理函数名作为参数传入，然后返回执行语句，仔细阅读以上代码就可以明白里面的意思了。</p><p>如果在jQuery中用JSONP的话就更加简单了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">$.getJSON(<span class="string">''</span>http:<span class="comment">//example.com/data.php?callback=?', function (data) &#123;</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(data);</span></span><br><span class="line"><span class="undefined">&#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意jQuery会自动生成一个全局函数来替换<code>callback=?</code>中的问号，之后获取到数据后又会自动销毁，实际上就是起一个临时代理函数的作用。<code>$.getJSON</code>方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用JSONP的回调函数。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>除了上述方法外，HTML5还新增了一个<code>window.postMessage()</code>方法，有兴趣的可以自行查阅。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>JavaScript实现类与继承的方法（全面整理）</title>
      <link href="/2018/10/08/JavaScript%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E5%85%A8%E9%9D%A2%E6%95%B4%E7%90%86%EF%BC%89/"/>
      <url>/2018/10/08/JavaScript%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E5%85%A8%E9%9D%A2%E6%95%B4%E7%90%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript定义类的4种方法"><a href="#JavaScript定义类的4种方法" class="headerlink" title="JavaScript定义类的4种方法"></a>JavaScript定义类的4种方法</h1><h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">creatPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line">obj.name = name;</span><br><span class="line">obj.age = age;</span><br><span class="line"></span><br><span class="line">obj.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">window</span>.alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">            </span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数方法"><a href="#构造函数方法" class="headerlink" title="构造函数方法"></a>构造函数方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">window</span>.alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原型方法"><a href="#原型方法" class="headerlink" title="原型方法"></a>原型方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line"><span class="keyword">constructor</span> : Person,</span><br><span class="line">name : "Ning",</span><br><span class="line">age : "23",</span><br><span class="line">sayName : function() &#123;</span><br><span class="line"><span class="built_in">window</span>.alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>大家可以看到这种方法有缺陷，类里属性的值都是在原型里给定的。</p><h2 id="组合使用构造函数和原型方法（使用最广）"><a href="#组合使用构造函数和原型方法（使用最广）" class="headerlink" title="组合使用构造函数和原型方法（使用最广）"></a>组合使用构造函数和原型方法（使用最广）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line"><span class="keyword">constructor</span> : Person, </span><br><span class="line">sayName : function() &#123;</span><br><span class="line"><span class="built_in">window</span>.alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将构造函数方法和原型方法结合使用是目前最常用的定义类的方法。这种方法的好处是实现了属性定义和方法定义的分离。比如我可以创建两个对象<code>person1</code>和<code>person2</code>，它们分别传入各自的<code>name</code>值和<code>age</code>值，但<code>sayName()</code>方法可以同时使用原型里定义的。</p><h1 id="JavaScript实现继承的3种方法"><a href="#JavaScript实现继承的3种方法" class="headerlink" title="JavaScript实现继承的3种方法"></a>JavaScript实现继承的3种方法</h1><h2 id="借用构造函数法（又叫经典继承）"><a href="#借用构造函数法（又叫经典继承）" class="headerlink" title="借用构造函数法（又叫经典继承）"></a>借用构造函数法（又叫经典继承）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">window</span>.alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">SuperType.call(<span class="keyword">this</span>, name); <span class="comment">//在这里借用了父类的构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象冒充"><a href="#对象冒充" class="headerlink" title="对象冒充"></a>对象冒充</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">window</span>.alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.supertype = SuperType; <span class="comment">//在这里使用了对象冒充</span></span><br><span class="line"><span class="keyword">this</span>.supertype(name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合继承（最常用）"><a href="#组合继承（最常用）" class="headerlink" title="组合继承（最常用）"></a>组合继承（最常用）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype = &#123;</span><br><span class="line"></span><br><span class="line">    sayName : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">window</span>.alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">SuperType.call(<span class="keyword">this</span>, name); <span class="comment">//在这里继承属性</span></span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); <span class="comment">//这里继承方法</span></span><br></pre></td></tr></table></figure><p>组合继承的方法是对应着我们用‘组合使用构造函数和原型方法’定义父类的一种继承方法。同样的，我们的属性和方法是分开继承的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是常见的JavaScript中面向对象编程的几种实现，欢迎大家补充与指正。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>为什么要使用闭包和如何使用闭包</title>
      <link href="/2018/10/07/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85%E5%92%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85/"/>
      <url>/2018/10/07/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85%E5%92%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>JS中的闭包是一个我们经常遇到的名词，到底什么是闭包？为什么我们要使用闭包？又该如何使用闭包呢？</p><h2 id="为什么我们需要闭包"><a href="#为什么我们需要闭包" class="headerlink" title="为什么我们需要闭包"></a>为什么我们需要闭包</h2><p>首先来看一个例子，我们来实现一个计数器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> counter += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line">add();<span class="comment">// 计数器现在为 3</span></span><br></pre></td></tr></table></figure><p>现在我们已经达到了目的，可是问题来了，代码中的任何一个函数都可以随意改变<code>counter</code>的值，所以这个计数器并不完美。那我们把<code>counter</code>放在<code>add</code>函数里面不就好了么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> counter += <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line">add();<span class="comment">// 本意是想输出 3, 但输出的都是 1</span></span><br></pre></td></tr></table></figure><p>所以这样做的话，每次调用<code>add</code>函数，<code>counter</code>的值都要被初始化为0，还是达不到我们的目的。</p><h2 id="如何使用闭包"><a href="#如何使用闭包" class="headerlink" title="如何使用闭包"></a>如何使用闭包</h2><p>所以这时候我们就要用闭包去解决这个问题了，先看代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">return</span> counter += <span class="number">1</span>;&#125;</span><br><span class="line">&#125;)();</span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line">add();<span class="comment">// 计数器为 3</span></span><br></pre></td></tr></table></figure><p>这时候我们完美实现了计数器。这段非常精简，可以拆分成如下等价代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> counter += <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> innerFunction;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> add = outerFunction();</span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line">add();<span class="comment">// 计数器为 3</span></span><br></pre></td></tr></table></figure><p>这时候的<code>add</code>就形成了一个闭包。一个闭包由两部分组成，函数和创建该函数的环境。环境是由环境中的局部变量组成的。对于闭包<code>add</code>来说，它由函数<code>innerFunction</code>和变量<code>counter</code>组成，所以这时候<code>add</code>是可以访问变量<code>counter</code>的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以闭包的功能就是使一个函数能访问另一个函数作用域中的变量。形成闭包之后，该变量不会被垃圾回收机制回收。</p><p>闭包的原理其实还是作用域。</p><p>使用闭包的优点是可以避免全局变量污染，缺点是容易造成内存泄露。 </p>]]></content>
      
      
      
    </entry>
    
  
  
</search>
